"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[7732],{38396:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>b,frontMatter:()=>p,metadata:()=>m,toc:()=>h});var a=n(87462),i=(n(67294),n(3905)),o=(n(81694),n(76596)),r=n(36533),l=(n(40505),n(1496)),s=n(74866),c=n(85162);const p={sidebar_position:2},d="Finite State Machine",m={unversionedId:"teen/fsm",id:"teen/fsm",title:"Finite State Machine",description:"A pluggable state machine implemented as a ScriptableObject in Unity is a powerful way to create flexible and reusable state-based logic for your game objects. It allows you to define custom data structures and behaviors that can be shared across multiple game objects.",source:"@site/docs/05-teen/fsm.md",sourceDirName:"05-teen",slug:"/teen/fsm",permalink:"/50033/docs/teen/fsm",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"ScriptableObject Game Architecture",permalink:"/50033/docs/teen/scriptobjgamearch"},next:{title:"Checkoff",permalink:"/50033/docs/teen/checkoff"}},u={},h=[{value:"The Pluggable FSM Architecture",id:"the-pluggable-fsm-architecture",level:2},{value:"State",id:"state",level:3},{value:"Action",id:"action",level:3},{value:"EventAction",id:"eventaction",level:3},{value:"Decision",id:"decision",level:3},{value:"Transition",id:"transition",level:3},{value:"State Controller",id:"state-controller",level:3},{value:"Create Mario State Controller",id:"create-mario-state-controller",level:2},{value:"Create Action Scripts",id:"create-action-scripts",level:2},{value:"SetupAnimatorAction",id:"setupanimatoraction",level:3},{value:"ClearPowerupAction",id:"clearpowerupaction",level:3},{value:"FireAttackAction",id:"fireattackaction",level:3},{value:"InvincibleAction",id:"invincibleaction",level:3},{value:"Create Action Scriptable Objects",id:"create-action-scriptable-objects",level:2},{value:"SetupAnimatorAction",id:"setupanimatoraction-1",level:3},{value:"ClearPowerupAction",id:"clearpowerupaction-1",level:3},{value:"FireAttackAction",id:"fireattackaction-1",level:3},{value:"InvincibleAction",id:"invincibleaction-1",level:3},{value:"Create Decision Scripts",id:"create-decision-scripts",level:2},{value:"TransformDecision",id:"transformdecision",level:3},{value:"CountdownDecision",id:"countdowndecision",level:3},{value:"Create Decision Scriptable Objects",id:"create-decision-scriptable-objects",level:2},{value:"Transform Decision",id:"transform-decision",level:3},{value:"Countdown Decision",id:"countdown-decision",level:3},{value:"Create State Scriptable Objects",id:"create-state-scriptable-objects",level:2},{value:"RemainInState",id:"remaininstate",level:3},{value:"Mario States",id:"mario-states",level:3},{value:"Update MarioStateController to Trigger EventAction",id:"update-mariostatecontroller-to-trigger-eventaction",level:2},{value:"Attach MarioStateController to Mario",id:"attach-mariostatecontroller-to-mario",level:2},{value:"Modify how &quot;Damage&quot; Works",id:"modify-how-damage-works",level:3},{value:"Modify how Powerup Works",id:"modify-how-powerup-works",level:3}],g={toc:h},k="wrapper";function b(e){let{components:t,...p}=e;return(0,i.kt)(k,(0,a.Z)({},g,p,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"finite-state-machine"},"Finite State Machine"),(0,i.kt)("p",null,"A pluggable state machine implemented as a ScriptableObject in Unity is a ",(0,i.kt)("strong",{parentName:"p"},"powerful")," way to create ",(0,i.kt)("span",{className:"orange-bold"},"flexible")," and ",(0,i.kt)("span",{className:"orange-bold"},"reusable")," state-based logic for your game objects. It allows you to define custom data structures and behaviors that can be ",(0,i.kt)("strong",{parentName:"p"},"shared")," across multiple game objects."),(0,i.kt)("p",null,"We begin by creating a State, Action, and Transition SO. The State SO describes a list of ",(0,i.kt)("strong",{parentName:"p"},"actions")," that have to be done in that state, and takes in a list of ",(0,i.kt)("strong",{parentName:"p"},"transitions")," to determine the next state that we can go to. Then we need to create a StateMachineController to be attached to the GameObject we want to control with the state machine. In this part of the lab, we will create a simple FSM to control Mario's state upon receiving different types of Powerups and Buffs. There will be ",(0,i.kt)("span",{className:"orange-bold"},"two")," FSMs: one that will control Mario's regular state (appearance), and another one to control its Buffs."),(0,i.kt)("p",null,"We will follow the this basic idea for Mario's state:"),(0,i.kt)(r.Z,{path:n(10749).Z,customClass:"invert-color",widthPercentage:"50%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"As for Buffs, we have this simple construct:"),(0,i.kt)(r.Z,{path:n(16418).Z,customClass:"invert-color",widthPercentage:"30%",mdxType:"ImageCard"}),(0,i.kt)("h2",{id:"the-pluggable-fsm-architecture"},"The Pluggable FSM Architecture"),(0,i.kt)("h3",{id:"state"},"State"),(0,i.kt)("mermaid",{value:"classDiagram\n    ScriptableObject --|> State\n    class State{\n        +Action[] setupActions\n        +Action[] actions\n        +EventAction[] eventTriggeredActions\n        +Action[] exitActions\n        +Transition[] transitions\n        +Color sceneGizmoColor\n        +UpdateState(StateController controller)\n        +DoSetupActions(StateController controller)\n        +DoActions(StateController controller)\n        +DoEventTriggeredActions(StateController controller)\n        +DoExitActions(StateController controller)\n        #CheckTransitions(StateController controller)\n\n    }"}),(0,i.kt)("br",null),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"state")," inherits SO, and is implemented as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="State.cs"',title:'"State.cs"'},'using System;\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "PluggableSM/State")]\npublic class State : ScriptableObject\n{\n    public Action[] setupActions;\n    public Action[] actions;\n    public EventAction[] eventTriggeredActions;\n    public Action[] exitActions;\n    public Transition[] transitions;\n\n    // for visualisation at the Scene\n    public Color sceneGizmoColor = Color.grey;\n\n    /********************************/\n    /* REGULAR METHODS */\n    // these regular methods cannot be overriden\n    public void UpdateState(StateController controller)\n    {\n        DoActions(controller);\n        CheckTransitions(controller);\n    }\n\n    protected void DoActions(StateController controller)\n    {\n        for (int i = 0; i < actions.Length; i++) actions[i].Act(controller);\n    }\n    public void DoSetupActions(StateController controller)\n    {\n        for (int i = 0; i < setupActions.Length; i++) setupActions[i].Act(controller);\n    }\n    public void DoExitActions(StateController controller)\n    {\n        for (int i = 0; i < exitActions.Length; i++) exitActions[i].Act(controller);\n    }\n\n    public void DoEventTriggeredActions(StateController controller, ActionType type = ActionType.Default)\n    {\n        // cast all actions that matches given type\n        foreach (EventAction eventTriggeredAction in eventTriggeredActions)\n        {\n            if (eventTriggeredAction.type == type)\n            {\n                eventTriggeredAction.action.Act(controller);\n            }\n        }\n    }\n\n    protected void CheckTransitions(StateController controller)\n    {\n        controller.transitionStateChanged = false; //reset\n        for (int i = 0; i < transitions.Length; ++i)\n        {\n            //check if the previous transition has caused a change. If yes, stop. Let Update() in StateController run again in the next state.\n            if (controller.transitionStateChanged)\n            {\n                break;\n            }\n            bool decisionSucceded = transitions[i].decision.Decide(controller);\n            if (decisionSucceded)\n            {\n                controller.TransitionToState(transitions[i].trueState);\n            }\n            else\n            {\n                controller.TransitionToState(transitions[i].falseState);\n            }\n        }\n    }\n    /********************************/\n\n}\n')),(0,i.kt)("p",null,"It mainly contains ",(0,i.kt)("span",{className:"orange-bold"},"regular methods")," (cannot be overriden) with the following functionality:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"UpdateState"),": called at every frame update by the state controller, we cast our actions and check for possible transitions"),(0,i.kt)("li",{parentName:"ol"},"Action-related methods: there are ",(0,i.kt)("span",{className:"orange-bold"},"four")," types of actions:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Exit")," and ",(0,i.kt)("strong",{parentName:"li"},"Setup")," Actions: to be done exactly ",(0,i.kt)("strong",{parentName:"li"},"once"),": when we first arrive at this state and when we ",(0,i.kt)("em",{parentName:"li"},"leave")," this state"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Actions"),": called at ",(0,i.kt)("strong",{parentName:"li"},"every frame update")," by ",(0,i.kt)("inlineCode",{parentName:"li"},"UpdateState"),". This is particularly useful if you have bots or NPCs, but not so much in the case of player-controlled Mario"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Event")," Triggered Actions: actions that should be executed whenever the controller wishes to cast it, could be due to certain events such as keyboard pressed or collision with other gameObjects"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"CheckTransitions"),": goes through every single transition listed under ",(0,i.kt)("inlineCode",{parentName:"li"},"transitions"),". Some decision resulted in a different state, while some results in the same state. If the gameObject has changed its state, we ",(0,i.kt)("inlineCode",{parentName:"li"},"break")," (stop checking for more transitions)")),(0,i.kt)("h3",{id:"action"},"Action"),(0,i.kt)("mermaid",{value:"classDiagram\n    ScriptableObject --|> Action\n    class Action{\n        +Act(StateController controller)\n    }"}),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," class also inherits SO. The exact implementation of each action differs depending on the action, and so we leave its method as ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="Action.cs"',title:'"Action.cs"'},"using UnityEngine;\n\npublic abstract class Action : ScriptableObject\n{\n    public abstract void Act(StateController controller);\n}\n")),(0,i.kt)("h3",{id:"eventaction"},"EventAction"),(0,i.kt)("p",null,"An ",(0,i.kt)("inlineCode",{parentName:"p"},"EventAction")," is simply a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," containing an ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," and its type. This is to allow the ",(0,i.kt)("inlineCode",{parentName:"p"},"State")," to loop through each registered ",(0,i.kt)("inlineCode",{parentName:"p"},"EventAction")," and cast an ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," whose ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," matches the user-defined type accordingly should a particular event occur:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="EventAction.cs"',title:'"EventAction.cs"'},"\npublic enum ActionType\n{\n    Attack = 0,\n    Default = -1\n}\n\n[System.Serializable]\npublic struct EventAction\n{\n    public Action action;\n    public ActionType type;\n}\n\n")),(0,i.kt)("h3",{id:"decision"},"Decision"),(0,i.kt)("mermaid",{value:"classDiagram\n    ScriptableObject --|> Decision\n    class Decision{\n        +Decide(Statecontroller controller)\n    }"}),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Decision")," class also inherits SO, and similarly we declare its method as ",(0,i.kt)("inlineCode",{parentName:"p"},"abstract")," first since its implementation varies greatly:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="Decision.cs"',title:'"Decision.cs"'},"using UnityEngine;\n\npublic abstract class Decision : ScriptableObject\n{\n    public abstract bool Decide(StateController controller);\n\n}\n")),(0,i.kt)("h3",{id:"transition"},"Transition"),(0,i.kt)("p",null,"A ",(0,i.kt)("inlineCode",{parentName:"p"},"Transition")," is simply a ",(0,i.kt)("inlineCode",{parentName:"p"},"struct")," to hold a ",(0,i.kt)("inlineCode",{parentName:"p"},"Decision"),", and two ",(0,i.kt)("inlineCode",{parentName:"p"},"State")," depending on whether that decision returns ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="Transition.cs"',title:'"Transition.cs"'},"[System.Serializable]\npublic class Transition\n{\n    public Decision decision;\n    public State trueState;\n    public State falseState;\n\n}\n")),(0,i.kt)("h3",{id:"state-controller"},"State Controller"),(0,i.kt)("p",null,"This script should be attached to the game object you wished to be the state machine. You can use it to manage buffs and powerups for your main character or to control NPCs or AI bots."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="StateController.cs"',title:'"StateController.cs"'},"using UnityEngine;\n\npublic abstract class StateController : MonoBehaviour\n{\n    public State startState;\n    public State previousState;\n    public State currentState;\n    public State remainState;\n    public bool transitionStateChanged = false;\n    [HideInInspector] public float stateTimeElapsed;\n\n    public bool isActive = true;\n\n    public virtual void Start()\n    {\n        OnSetupState(); // setup when game starts\n    }\n\n    public virtual void OnSetupState()\n    {\n        if (currentState)\n            currentState.DoSetupActions(this);\n    }\n\n    public virtual void OnExitState()\n    {\n        // reset time in this state\n        stateTimeElapsed = 0;\n        if (currentState)\n            currentState.DoExitActions(this);\n    }\n\n    // for visual aid to indicate which state this object is currently at\n    public virtual void OnDrawGizmos()\n    {\n        if (currentState != null)\n        {\n            Gizmos.color = currentState.sceneGizmoColor;\n            Gizmos.DrawWireSphere(this.transform.position, 1.0f);\n        }\n    }\n\n    /********************************/\n    // Regular methods\n    // no action should be done here, strictly for transition\n    public void TransitionToState(State nextState)\n    {\n        if (nextState == remainState) return;\n\n        // The following two methods only happens once if nextState != remainstate\n        OnExitState(); // cast exit action if any,\n\n        // transition the states\n        previousState = currentState;\n        currentState = nextState;\n        transitionStateChanged = true;\n\n        OnSetupState(); // cast entry action if any\n    }\n\n    // default method to check if we've been in the state long enough\n    // this method assumes that you will call this once per update frame\n    // Time.deltaTime: the interval in seconds from the last frame to the current one (Read Only).\n    public bool CheckIfCountDownElapsed(float duration)\n    {\n        stateTimeElapsed += Time.deltaTime;\n        return stateTimeElapsed >= duration;\n    }\n\n    public void Update()\n    {\n        if (!isActive) return; // this is different from gameObject active, allow for separate control\n\n        currentState.UpdateState(this);\n    }\n    /********************************/\n\n\n\n\n}\n\n")),(0,i.kt)("admonition",{title:"important",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"You will need to inherit the ",(0,i.kt)("inlineCode",{parentName:"p"},"StateController")," to suit your own needs. There are three regular methods that you should not modify, and for virtual methods which you can ",(0,i.kt)("inlineCode",{parentName:"p"},"override"),". Dont forget to call ",(0,i.kt)("inlineCode",{parentName:"p"},"base.[method]()")," if you want to invoke the parent's implementation as well. Take your time to read how things work in ",(0,i.kt)("inlineCode",{parentName:"p"},"StateController"),".")),(0,i.kt)("h2",{id:"create-mario-state-controller"},"Create Mario State Controller"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MarioStateController")," is a script that we will attach to Mario to control its powerup effect. You can extend this class however you like, but we shall start by inheriting the base class ",(0,i.kt)("inlineCode",{parentName:"p"},"StateController"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="MarioStateController.cs"',title:'"MarioStateController.cs"'},"using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class MarioStateController : StateController\n{\n    public PowerupType currentPowerupType = PowerupType.Default;\n    public MarioState shouldBeNextState = MarioState.Default;\n\n\n    public override void Start()\n    {\n        base.Start();\n        GameRestart(); // clear powerup in the beginning, go to start state\n    }\n\n    // this should be added to the GameRestart EventListener as callback\n    public void GameRestart()\n    {\n        // clear powerup\n        currentPowerupType = PowerupType.Default;\n        // set the start state\n        TransitionToState(startState);\n    }\n\n    public void SetPowerup(PowerupType i)\n    {\n        currentPowerupType = i;\n    }\n\n}\n")),(0,i.kt)("admonition",{title:"MarioState Enum",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"To make life easier, we use an ",(0,i.kt)("inlineCode",{parentName:"p"},"Enum")," to define ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioState"),":"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="MarioState.cs"',title:'"MarioState.cs"'},"\npublic enum MarioState\n{\n    Default = -1,\n    SmallMario = 0,\n    SuperMario = 1,\n    FireMario = 2,\n    InvincibleSmallMario = 3,\n    DeadMario = 99\n}\n"))),(0,i.kt)("h2",{id:"create-action-scripts"},"Create Action Scripts"),(0,i.kt)("p",null,"Since ",(0,i.kt)("inlineCode",{parentName:"p"},"Action")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Decision")," are highly specific to our use cases, we need to create scripts that describe ",(0,i.kt)("em",{parentName:"p"},"what")," we should do. Let's start with ",(0,i.kt)("strong",{parentName:"p"},"actions")," first, there are three categories of actions from this FSM diagram we had above:"),(0,i.kt)(r.Z,{path:n(10749).Z,customClass:"invert-color",widthPercentage:"50%",mdxType:"ImageCard"}),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Regular Action: ",(0,i.kt)("inlineCode",{parentName:"li"},"FireAttackAction")),(0,i.kt)("li",{parentName:"ol"},"Setup Action: ",(0,i.kt)("inlineCode",{parentName:"li"},"SetupAnimatorAction"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"ClearPowerupAction"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"InvincibleAction"))),(0,i.kt)("h3",{id:"setupanimatoraction"},"SetupAnimatorAction"),(0,i.kt)("p",null,"This script swaps Mario's current animator to be the other. It will only be done ",(0,i.kt)("strong",{parentName:"p"},"once"),", for example when entering SuperMario state, or when entering FireMario state. This entirely changes how Mario looks:"),(0,i.kt)(l.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-5/change-animator.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="SetupAnimatorAction.cs"',title:'"SetupAnimatorAction.cs"'},'using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n\n[CreateAssetMenu(menuName = "PluggableSM/Actions/SetupAnimator")]\npublic class SetupAnimator : Action\n{\n    public RuntimeAnimatorController animatorController;\n    public override void Act(StateController controller)\n    {\n        controller.gameObject.GetComponent<Animator>().runtimeAnimatorController = animatorController;\n    }\n}\n')),(0,i.kt)("p",null,"The method ",(0,i.kt)("inlineCode",{parentName:"p"},"Act")," receives a ",(0,i.kt)("inlineCode",{parentName:"p"},"StateController")," parameter, which you can use to access the ",(0,i.kt)("inlineCode",{parentName:"p"},"gameObject")," it is attached to and access its components using ",(0,i.kt)("inlineCode",{parentName:"p"},"GetComponent"),"."),(0,i.kt)("h3",{id:"clearpowerupaction"},"ClearPowerupAction"),(0,i.kt)("p",null,"This action ",(0,i.kt)("strong",{parentName:"p"},"removes")," the current powerup registered as member in MarioState controller."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="ClearPowerupAAction.cs"',title:'"ClearPowerupAAction.cs"'},'using UnityEngine;\n\n[CreateAssetMenu(menuName = "PluggableSM/Actions/ClearPowerup")]\npublic class ClearPowerupAction : Action\n{\n    public override void Act(StateController controller)\n    {\n        MarioStateController m = (MarioStateController)controller;\n        m.currentPowerupType = PowerupType.Default;\n    }\n}\n')),(0,i.kt)("p",null,"Since the method ",(0,i.kt)("inlineCode",{parentName:"p"},"Act")," accepts ",(0,i.kt)("inlineCode",{parentName:"p"},"StateController")," parameter, we need to ",(0,i.kt)("span",{className:"orange-bold"},"cast")," it to ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioStateController")," first before being able to access the member ",(0,i.kt)("inlineCode",{parentName:"p"},"currentPowerupType"),"."),(0,i.kt)("admonition",{title:"PowerupType Enum",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"To make life easier, we use an ",(0,i.kt)("inlineCode",{parentName:"p"},"Enum")," to define our ",(0,i.kt)("inlineCode",{parentName:"p"},"PowerupType"),". Use this to label each ",(0,i.kt)("inlineCode",{parentName:"p"},"Powerup")," present in the game."),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="PowerupType.cs"',title:'"PowerupType.cs"'},"public enum PowerupType\n{\n    Coin = 0,\n    MagicMushroom = 1,\n    OneUpMushroom = 2,\n    StarMan = 3,\n    FireFlower = 4,\n    Damage = 99,\n    Default = -1\n}\n")),(0,i.kt)("span",{className:"orange-bold"},'Note how `Damage` is some kind of "PowerupType" too. You will need to make further modifications to make this work'),"."),(0,i.kt)("h3",{id:"fireattackaction"},"FireAttackAction"),(0,i.kt)("p",null,"This action is called whenever the key 'Z' is pressed and whenever Mario is at FireMario state as follows:"),(0,i.kt)(l.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-5/fireball.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="FireAttackAction.cs"',title:'"FireAttackAction.cs"'},'using UnityEngine;\n\n[CreateAssetMenu(menuName = "PluggableSM/Actions/FireAttack")]\npublic class FireAttackAction : Action\n{\n    public int maxPrefabInScene = 3;\n    public float impulseForce = 1;\n    public float degree = 45;\n    public GameObject attackPrefab;\n    // a scriptable object updated by PlayerMovement / PlayerController to store current Mario\'s facing\n    public BoolVariable marioFaceRight;\n\n    public override void Act(StateController controller)\n    {\n        GameObject[] instantiatedPrefabsInScene = GameObject.FindGameObjectsWithTag(attackPrefab.tag);\n        if (instantiatedPrefabsInScene.Length < maxPrefabInScene)\n        {\n            // instantiate it where controller (mario) is\n            GameObject x = Instantiate(attackPrefab, controller.transform.position, Quaternion.identity);\n\n            // Get the Rigidbody component of the instantiated object\n            Rigidbody2D rb = x.GetComponent<Rigidbody2D>();\n            // Check if the Rigidbody component exists\n            if (rb != null)\n            {\n                // compute direction vector\n                Vector2 direction = CalculateDirection(degree, marioFaceRight.Value);\n                // Apply a rightward impulse force to the object\n                rb.AddForce(direction * impulseForce, ForceMode2D.Impulse);\n            }\n\n        }\n\n    }\n\n    public Vector2 CalculateDirection(float degrees, bool isFacingRight)\n    {\n        // Convert degrees to radians\n        float radians = degrees * Mathf.Deg2Rad;\n\n        // Calculate the direction vector\n        float x = Mathf.Cos(radians);\n        float y = Mathf.Sin(radians);\n\n        // If the object is facing left, invert the x-component of the direction\n        if (!isFacingRight)\n        {\n            x = -x;\n        }\n\n        return new Vector2(x, y);\n    }\n}\n\n')),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"Act")," is called, we instantiate a prefab ",(0,i.kt)("inlineCode",{parentName:"p"},"attackPrefab")," and spawn it based on the direction that Mario is facing, 45 degrees upwards with an initial impulseForce. We added some little constraint to prevent spamming of this prefab by limiting only 3 prefabs on the scene at a time."),(0,i.kt)(o.Z,{title:"Fireball Prefab",mdxType:"DeepDive"},"You are free to create your own custom fireball prefab, but here's how we implement it with a Coroutine so that it only lasts for about 2.5 seconds and destroys itself when colliding with Enemy:",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="FireballController.cs"',title:'"FireballController.cs"'},'using System.Collections;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing UnityEngine;\n\npublic class FireballController : MonoBehaviour\n{\n    // Start is called before the first frame update\n    [SerializeField] private float scaleSpeed = 1.0f;\n\n    void Start()\n    {\n        StartCoroutine(ScaleAndDestroyCoroutine());\n        GetComponent<AudioSource>().Play();\n    }\n\n    private IEnumerator ScaleAndDestroyCoroutine()\n    {\n        // Wait for 2 seconds\n        yield return new WaitForSecondsRealtime(2);\n        // Gradually scale down the GameObject\n        while (transform.localScale.x > 0.01f)\n        {\n            transform.localScale -= Vector3.one * scaleSpeed * Time.deltaTime;\n            yield return null;\n        }\n\n        // Ensure the GameObject is completely scaled down\n        transform.localScale = Vector3.zero;\n\n        // Destroy the GameObject\n        Destroy(gameObject);\n    }\n\n    void OnCollisionEnter2D(Collision2D collision)\n    {\n        if (collision.gameObject.tag == "Enemy")\n        {\n            // destroy self\n            Destroy(gameObject);\n        }\n    }\n}\n')),(0,i.kt)("p",null,"To create the prefab, simply add the following components and attach the script above to it:"),(0,i.kt)(r.Z,{path:n(95187).Z,widthPercentage:"100%",mdxType:"ImageCard"})),(0,i.kt)("h3",{id:"invincibleaction"},"InvincibleAction"),(0,i.kt)("p",null,"This action happens when SuperMario or FireMario collides with Goomba. We need to rapidly enable and disable Mario's SpriteRenderer (flicker) until Mario's state is no longer ",(0,i.kt)("inlineCode",{parentName:"p"},"InvincibleSmallMario"),". Since ",(0,i.kt)("inlineCode",{parentName:"p"},"InvincibleAction")," is a ScriptableObject, we cannot utilise Coroutines. As such the actual ",(0,i.kt)("strong",{parentName:"p"},"implementation")," of Mario's flickering sprite should be implemented within ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioStateController"),". The ",(0,i.kt)("inlineCode",{parentName:"p"},"InvincibleAction")," simply ",(0,i.kt)("span",{className:"orange-bold"},"calls")," that method."),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(c.Z,{value:"1",label:"InvincibleAction.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "PluggableSM/Actions/SetupInvincibility")]\npublic class InvincibleAction : Action\n{\n    public AudioClip invincibilityStart;\n    public override void Act(StateController controller)\n    {\n        MarioStateController m = (MarioStateController)controller;\n        m.gameObject.GetComponent<AudioSource>().PlayOneShot(invincibilityStart);\n        m.SetRendererToFlicker();\n    }\n}\n\n'))),(0,i.kt)(c.Z,{value:"2",label:"MarioStateController.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using System;\nusing System.Collections;\nusing UnityEngine;\n\npublic class MarioStateController : StateController\n{\n    //highlight-start\n    private SpriteRenderer spriteRenderer;\n//highlight-end\n\n    // other methods\n    //highlight-start\n    public void SetRendererToFlicker()\n    {\n        spriteRenderer = GetComponent<SpriteRenderer>();\n        StartCoroutine(BlinkSpriteRenderer());\n    }\n    private IEnumerator BlinkSpriteRenderer()\n    {\n        spriteRenderer = GetComponent<SpriteRenderer>();\n        while (string.Equals(currentState.name, "InvincibleSmallMario", StringComparison.OrdinalIgnoreCase))\n        {\n            // Toggle the visibility of the sprite renderer\n            spriteRenderer.enabled = !spriteRenderer.enabled;\n\n            // Wait for the specified blink interval\n            yield return new WaitForSeconds(gameConstants.flickerInterval);\n        }\n\n        spriteRenderer.enabled = true;\n    }\n    //highlight-end\n\n}\n')))),(0,i.kt)("h2",{id:"create-action-scriptable-objects"},"Create Action Scriptable Objects"),(0,i.kt)("h3",{id:"setupanimatoraction-1"},"SetupAnimatorAction"),(0,i.kt)("p",null,"We now ",(0,i.kt)("strong",{parentName:"p"},"instantiate")," these actions accordingly. Right click at the Project window and select ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupAnimator")," Action:"),(0,i.kt)(r.Z,{path:n(57554).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"Name it ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupSmallMario"),", and attach ",(0,i.kt)("inlineCode",{parentName:"p"},"Mario")," animator in the Animator Controller field:"),(0,i.kt)(r.Z,{path:n(78867).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"Now you need to create DeadMario, SuperMario and FireMario Animators as well, and then create three more ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupAnimator")," Action, name it ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupDeadMario"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupSuperMario")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupFireMario"),". Here's a preview of the animators required:"),(0,i.kt)(l.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-5/setup-more-animators.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,i.kt)(o.Z,{title:"Animation Event on Animators not Attached to gameObject",mdxType:"DeepDive"},"Note that if you want to call an Animation Event from `mario-die` animation clip, you can attach it to Mario first and set up necessary functions as per normal from such function dropdown at the ",(0,i.kt)("span",{className:"orange-bold"},"inspector"),":",(0,i.kt)(r.Z,{path:n(85513).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"When you switch Mario's animator to other animator, DeadMario animator and clips becomes standalone (not associated with any object). The event will work just fine, but notice how they're matched based on name:"),(0,i.kt)(r.Z,{path:n(45958).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"Hence next time you attach DeadMario as Mario's animator, it will find a function called ",(0,i.kt)("inlineCode",{parentName:"p"},"PlayDeathImpulse")," in any of Mario's attached script.")),(0,i.kt)("p",null,"By now you should have four setup actions: ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupSmallMario"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupSuperMario"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupFireMario"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"SetupDeadMario"),"."),(0,i.kt)("h3",{id:"clearpowerupaction-1"},"ClearPowerupAction"),(0,i.kt)("p",null,"There's nothing to set up for this action, simply instantiate it and name it ",(0,i.kt)("inlineCode",{parentName:"p"},"ClearPowerup"),":"),(0,i.kt)(r.Z,{path:n(25341).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("h3",{id:"fireattackaction-1"},"FireAttackAction"),(0,i.kt)("p",null,"Create this action and name it ",(0,i.kt)("inlineCode",{parentName:"p"},"FireAttackAction"),", link up the necessary values in the inspector:"),(0,i.kt)(r.Z,{path:n(46209).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)(o.Z,{title:"BoolVariable",mdxType:"DeepDive"},(0,i.kt)("p",null,"Although not explicitly stated, you should know that ",(0,i.kt)("inlineCode",{parentName:"p"},"BoolVariable")," is a scriptable object containing a boolean value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="BoolVariable.cs"',title:'"BoolVariable.cs"'},'using UnityEngine;\n\n[CreateAssetMenu(fileName = "BoolVariable", menuName = "ScriptableObjects/BoolVariable", order = 2)]\npublic class BoolVariable : Variable<bool>\n{\n\n    public override void SetValue(bool value)\n    {\n        _value = value;\n    }\n\n    // overload\n    public void SetValue(BoolVariable value)\n    {\n        SetValue(value.Value);\n    }\n\n    public void Toggle()\n    {\n        _value = !_value;\n    }\n\n}\n')),(0,i.kt)("p",null,"We instantiate it and named it ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioFaceRight"),":"),(0,i.kt)(r.Z,{path:n(88752).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"Then we manipulate its value in ",(0,i.kt)("inlineCode",{parentName:"p"},"PlayerController.cs"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="PlayerController.cs"',title:'"PlayerController.cs"'},'public class PlayerControllerWeek5 : MonoBehaviour, IPowerupApplicable\n{\n    //highlight-start\n    public BoolVariable marioFaceRight;\n    //highlight-end\n\n    void FlipMarioSprite(int value)\n    {\n        if (value == -1 && faceRightState)\n        {\n            //highlight-start\n            updateMarioShouldFaceRight(false);\n            //highlight-end\n            marioSprite.flipX = !faceRightState;\n            if (marioBody.velocity.x > 0.05f)\n                marioAnimator.SetTrigger("onSkid");\n\n        }\n\n        else if (value == 1 && !faceRightState)\n        {\n            //highlight-start\n            updateMarioShouldFaceRight(true);\n            //highlight-end\n            marioSprite.flipX = !faceRightState;\n            if (marioBody.velocity.x < -0.05f)\n                marioAnimator.SetTrigger("onSkid");\n        }\n    }\n\n    //highlight-start\n    private void updateMarioShouldFaceRight(bool value)\n    {\n        faceRightState = value;\n        marioFaceRight.SetValue(faceRightState);\n    }\n    //highlight-end\n\n}\n')),(0,i.kt)("p",null,"This way we can know whether to cast the fireball to the right or to the left depending on Mario's current facing.")),(0,i.kt)("h3",{id:"invincibleaction-1"},"InvincibleAction"),(0,i.kt)("p",null,"For this action, there's nothing much you need to do except to instantiate it and give it the desired Audio Clip to play when this action starts:"),(0,i.kt)(r.Z,{path:n(61781).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("h2",{id:"create-decision-scripts"},"Create Decision Scripts"),(0,i.kt)("p",null,"These scripts inherit the ",(0,i.kt)("inlineCode",{parentName:"p"},"Decision")," class, and must implement one method ",(0,i.kt)("inlineCode",{parentName:"p"},"Decide")," which returns a boolean value."),(0,i.kt)("h3",{id:"transformdecision"},"TransformDecision"),(0,i.kt)("p",null,"This decision determines whether we should transform into another state given the current state and the current powerup:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="TransformDecision.cs"',title:'"TransformDecision.cs"'},'\nusing UnityEngine;\nusing System;\n[CreateAssetMenu(menuName = "PluggableSM/Decisions/Transform")]\npublic class TransformDecision : Decision\n{\n    public StateTransformMap[] map;\n\n    public override bool Decide(StateController controller)\n    {\n        MarioStateController m = (MarioStateController)controller;\n        // we assume that the state is named (string matched) after one of possible values in MarioState\n        // convert between current state name into MarioState enum value using custom class EnumExtension\n        // you are free to modify this to your own use\n        MarioState toCompareState = EnumExtension.ParseEnum<MarioState>(m.currentState.name);\n\n        // loop through state transform and see if it matches the current transformation we are looking for\n        for (int i = 0; i < map.Length; i++)\n        {\n            if (toCompareState == map[i].fromState && m.currentPowerupType == map[i].powerupCollected)\n            {\n                return true;\n            }\n        }\n\n        return false;\n\n    }\n}\n\n[System.Serializable]\npublic struct StateTransformMap\n{\n    public MarioState fromState;\n    public PowerupType powerupCollected;\n}\n\n')),(0,i.kt)(o.Z,{title:"EnumExtension.cs",mdxType:"DeepDive"},"This is a custom class to easily convert between the string or integer representation of an enum to the enum:",(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="EnumExtension.cs"',title:'"EnumExtension.cs"'},"\n\nusing System;\n\npublic static class EnumExtension\n{\n    public static T ParseEnum<T>(string input) where T : struct\n    {\n        // return the enum value given a string\n        T enumValue;\n        if (Enum.TryParse(input, true, out enumValue))\n        {\n            return enumValue;\n        }\n        return default(T);\n    }\n\n    public static int ParseEnumToInteger<T>(string input) where T : struct\n    {\n        // return the integer enum given a string\n        T enumValue = ParseEnum<T>(input);\n        if (Enum.IsDefined(typeof(T), enumValue))\n        {\n            return Convert.ToInt32(enumValue);\n        }\n        return -1;\n    }\n\n}\n\n"))),(0,i.kt)("h3",{id:"countdowndecision"},"CountdownDecision"),(0,i.kt)("p",null,"Another decision that we can create is to detect if we have been in the current state longer than a stipulated duration by calling the state controller's ",(0,i.kt)("inlineCode",{parentName:"p"},"CheckIfCountdownElapsed")," regular method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="CountdownDecision.cs"',title:'"CountdownDecision.cs"'},'using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n[CreateAssetMenu(menuName = "PluggableSM/Decisions/Countdown")]\npublic class CountdownDecision : Decision\n{\n    public float buffDuration;\n    public override bool Decide(StateController controller)\n    {\n        return controller.CheckIfCountDownElapsed(buffDuration);\n    }\n}\n')),(0,i.kt)("h2",{id:"create-decision-scriptable-objects"},"Create Decision Scriptable Objects"),(0,i.kt)("h3",{id:"transform-decision"},"Transform Decision"),(0,i.kt)("p",null,"We have several decisions that we have to make depending on which MarioState we want to transform to:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ShouldTransformToSuperMario")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ShouldTransformToFireMario")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ShouldTransformToDeadMario")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"ShouldTransformToInvincibleMario"))),(0,i.kt)(l.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-5/should-transform.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,i.kt)("admonition",{title:"How Transform Decision Works",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"We create various Transform Decision SO and hard-code the decision we are looking for in that instance:"),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},"The idea is that the method ",(0,i.kt)("inlineCode",{parentName:"li"},"Decide")," will return ",(0,i.kt)("inlineCode",{parentName:"li"},"true")," if current state and powerup matches what's described in the ",(0,i.kt)("inlineCode",{parentName:"li"},"Decision"),"."),(0,i.kt)("li",{parentName:"ul"},"For example, ",(0,i.kt)("inlineCode",{parentName:"li"},"ShouldTransformToSuperMario")," has one of its ",(0,i.kt)("inlineCode",{parentName:"li"},"Map")," element ",(0,i.kt)("inlineCode",{parentName:"li"},"fromState")," value set to ",(0,i.kt)("inlineCode",{parentName:"li"},"SmallMario")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"powerupCollected")," value value set to ",(0,i.kt)("inlineCode",{parentName:"li"},"MagicMushroom"),"."),(0,i.kt)("li",{parentName:"ul"},"Hence, if the controller's current state name is ",(0,i.kt)("inlineCode",{parentName:"li"},"SmallMario")," and current Powerup collected is ",(0,i.kt)("inlineCode",{parentName:"li"},"Magic Mushroom"),", then ",(0,i.kt)("inlineCode",{parentName:"li"},"ShouldTransformToSuperMario")," should return ",(0,i.kt)("inlineCode",{parentName:"li"},"true")))),(0,i.kt)("h3",{id:"countdown-decision"},"Countdown Decision"),(0,i.kt)("p",null,"The countdown decision is fairly straightforward, you are free to set the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"buffDuration"),":"),(0,i.kt)(r.Z,{path:n(58213).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("h2",{id:"create-state-scriptable-objects"},"Create State Scriptable Objects"),(0,i.kt)("p",null,"Now that we have all our actions and decisions ready, it is time to create the states. As per the fsm diagram, we need ",(0,i.kt)("strong",{parentName:"p"},"five")," states:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"DeadMario")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"FireMario")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"InvincibleSmallMario")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"SmallMario")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"SuperMario"))),(0,i.kt)("h3",{id:"remaininstate"},"RemainInState"),(0,i.kt)("p",null,'We need a "dummy" state to indicate that we ',(0,i.kt)("span",{className:"orange-bold"},"remain in state"),". Create this dummy state first and leave the inspector empty:"),(0,i.kt)(r.Z,{path:n(70010).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("h3",{id:"mario-states"},"Mario States"),(0,i.kt)("p",null,"Now create five more state instances and name them accordingly. You will then need to modify its members in the inspector. Here's the specs of ",(0,i.kt)("inlineCode",{parentName:"p"},"FireMario"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"There exist ",(0,i.kt)("strong",{parentName:"li"},"two")," setup actions: setup fire mario animator and clear the powerup in ",(0,i.kt)("inlineCode",{parentName:"li"},"MarioStateController")),(0,i.kt)("li",{parentName:"ol"},"There exist also one event-triggered action: ",(0,i.kt)("inlineCode",{parentName:"li"},"FireAttack")," of ",(0,i.kt)("inlineCode",{parentName:"li"},"ActionType.Attack")," (enum defined in ",(0,i.kt)("inlineCode",{parentName:"li"},"EventAction.cs"),"). It will not be called every frame, but rather only when ",(0,i.kt)("inlineCode",{parentName:"li"},"Z")," key is pressed. ",(0,i.kt)("span",{className:"orange-bold"},"We will explicitly call this later in ",(0,i.kt)("inlineCode",{parentName:"li"},"MarioStateController")),"."),(0,i.kt)("li",{parentName:"ol"},"There's also only one transition to consider: which determines whether it should go to ",(0,i.kt)("inlineCode",{parentName:"li"},"InvincibleSmallMario")," state or ",(0,i.kt)("inlineCode",{parentName:"li"},"RemainInState")," (our dummy state).")),(0,i.kt)(r.Z,{path:n(33176).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"Recall that in ",(0,i.kt)("inlineCode",{parentName:"p"},"StateController.cs"),", we keep track of ",(0,i.kt)("inlineCode",{parentName:"p"},"RemainState")," State. This is useful for detecting whether we transition between different states or stay in the same state."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Of course you may skip this functionality and use some name matching to check if ",(0,i.kt)("inlineCode",{parentName:"p"},"currentState.name == previousState.name")," to determine whether you state has transitioned, but plain old string matching isn't fun \ud83e\udd79.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"public abstract class StateController : MonoBehaviour\n{\n    public State startState;\n    public State previousState;\n    public State currentState;\n\n    //highlight-start\n    public State remainState;\n    //highlight-end\n\n    public void TransitionToState(State nextState)\n    {\n        //highlight-start\n        if (nextState == remainState) return;\n        //highlight-end\n        // other instructions\n    }\n\n    // other methods\n\n}\n")),(0,i.kt)("h2",{id:"update-mariostatecontroller-to-trigger-eventaction"},"Update MarioStateController to Trigger EventAction"),(0,i.kt)("p",null,"The last thing that we need to do is to update our ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioStateController")," script to launch ",(0,i.kt)("inlineCode",{parentName:"p"},"FireAttack")," when key 'Z' is pressed. Add a new public void method called ",(0,i.kt)("inlineCode",{parentName:"p"},"Fire"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="MarioStateController.cs"',title:'"MarioStateController.cs"'},"    public void Fire()\n    {\n        this.currentState.DoEventTriggeredActions(this, ActionType.Attack);\n    }\n")),(0,i.kt)("p",null,"This will calls the ",(0,i.kt)("inlineCode",{parentName:"p"},"Act")," method of ",(0,i.kt)("span",{className:"orange-bold"},"all")," registered event-triggered actions in this state whose ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," matches ",(0,i.kt)("inlineCode",{parentName:"p"},"ActionType.Attack"),". You should link up this method to whatever ",(0,i.kt)("inlineCode",{parentName:"p"},"ActionManager")," script which sanitises the input from Input System."),(0,i.kt)("h2",{id:"attach-mariostatecontroller-to-mario"},"Attach MarioStateController to Mario"),(0,i.kt)("p",null,"The final step is to attach ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioStateController")," script to Mario:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Set its ",(0,i.kt)("inlineCode",{parentName:"li"},"StartState")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"SmallMario")),(0,i.kt)("li",{parentName:"ul"},"Set ",(0,i.kt)("inlineCode",{parentName:"li"},"RemainState")," as ",(0,i.kt)("inlineCode",{parentName:"li"},"RemainInState")," (our dummy state)"),(0,i.kt)("li",{parentName:"ul"},"If you utilise ",(0,i.kt)("inlineCode",{parentName:"li"},"GameConstants"),", you need to link it up here")),(0,i.kt)(r.Z,{path:n(67415).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("h3",{id:"modify-how-damage-works"},'Modify how "Damage" Works'),(0,i.kt)("p",null,"When Mario collides with Goomba, there has to be a way for us to set ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioStateController"),"'s current powerup member to ",(0,i.kt)("inlineCode",{parentName:"p"},"PowerupType.Damage"),'. One suggested way is to modify your existing "damage player" callback in ',(0,i.kt)("inlineCode",{parentName:"p"},"PlayerController"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="PlayerController.cs"',title:'"PlayerController.cs"'},"    public void DamageMario()\n    {\n        // GameOverAnimationStart(); // last time Mario dies right away\n\n        // pass this to StateController to see if Mario should start game over\n        // since both state StateController and MarioStateController are on the same gameobject, it's ok to cross-refer between scripts\n        GetComponent<MarioStateController>().SetPowerup(PowerupType.Damage);\n\n    }\n")),(0,i.kt)("p",null,"We assume the above is the callback you use when listening to ",(0,i.kt)("inlineCode",{parentName:"p"},"OnPlayerDamaged")," event:"),(0,i.kt)(r.Z,{path:n(80824).Z,widthPercentage:"60%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Update()")," method of ",(0,i.kt)("inlineCode",{parentName:"p"},"MarioStateController")," will always re-run the Decisions registered under ",(0,i.kt)("inlineCode",{parentName:"p"},"SmallMario")," state at each frame:"),(0,i.kt)(r.Z,{path:n(76018).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,i.kt)("p",null,"As a result, the moment we collide with Goomba whilst in ",(0,i.kt)("inlineCode",{parentName:"p"},"SmallMario")," state will trigger MarioStateController to switch Mario's state into ",(0,i.kt)("inlineCode",{parentName:"p"},"DeadMario"),", and the default animation clip on ",(0,i.kt)("inlineCode",{parentName:"p"},"DeadMario")," will play (which calles ",(0,i.kt)("inlineCode",{parentName:"p"},"PlayDeathImpulse")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"GameOverScene")," methods in Mario's scripts respectively):"),(0,i.kt)(l.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-5/mario-damaged-fsm.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,i.kt)("h3",{id:"modify-how-powerup-works"},"Modify how Powerup Works"),(0,i.kt)("p",null,"Each powerup script needs to set MarioStateController's ",(0,i.kt)("inlineCode",{parentName:"p"},"currentPowerupType")," whenever a powerup is collected. If you have been following the lab closely, you can modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"ApplyPowerup")," method in each class inheriting ",(0,i.kt)("inlineCode",{parentName:"p"},"BasePowerup")," class as follows:"),(0,i.kt)(s.Z,{mdxType:"Tabs"},(0,i.kt)(c.Z,{value:"1",label:"MagicMushroomPowerup.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"    public override void ApplyPowerup(MonoBehaviour i)\n    {\n        base.ApplyPowerup(i);\n        // try\n        MarioStateController mario;\n        bool result = i.TryGetComponent<MarioStateController>(out mario);\n        if (result)\n        {\n            mario.SetPowerup(this.powerupType);\n        }\n    }\n"))),(0,i.kt)(c.Z,{value:"2",label:"FireFlowerPowerup.cs",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"    public override void ApplyPowerup(MonoBehaviour i)\n    {\n        base.ApplyPowerup(i);\n        // try\n        MarioStateController mario;\n        bool result = i.TryGetComponent<MarioStateController>(out mario);\n        if (result)\n        {\n            mario.SetPowerup(this.powerupType);\n        }\n    }\n\n")))),(0,i.kt)("admonition",{type:"playtest"},(0,i.kt)("p",{parentName:"admonition"},"Changing MarioStateController's ",(0,i.kt)("inlineCode",{parentName:"p"},"currentPowerupType")," member will trigger state transition depending on its ",(0,i.kt)("inlineCode",{parentName:"p"},"currentState"),". When small mario obtains the magic mushroom, he transforms to super mario. If he is damaged by Goomba, he will enter invincible small Mario state where he cant be damaged by Goombas."),(0,i.kt)(l.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-5/supermario.mp4",widthPercentage:"100%",mdxType:"VideoItem"})))}b.isMDXComponent=!0},95187:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-11-52-06-83d465969a273b2a686248f598959f2e.png"},57554:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-11-59-51-713a52a9139f2510ded0e5a059397f03.png"},78867:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-01-12-f8e5b60fddadb4f44d21e7334a1688d2.png"},25341:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-08-51-517f9150d93babda1e85aad23ed23fad.png"},46209:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-09-38-d122d698c365e6210082b73b8e545b2a.png"},88752:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-11-28-1f0d9b31280d8a7711375f1acc56a249.png"},61781:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-16-50-aeb2267aea21dc147c50b0ed2ffb9742.png"},58213:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-34-17-d30ee62b638a8568d5a0a29fee192023.png"},33176:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-42-23-c48c0c1e0fe656b0f99e7baf3906f63b.png"},70010:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-48-46-a6ec0ce035722feee4714ff57a0ee9a6.png"},67415:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-12-58-05-eed4419e0febc99951e9676ded069946.png"},80824:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-13-05-52-01d19de8e387a429213d11aa63f6fa95.png"},76018:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-13-07-14-c893bcf510cfed99b0bf1ee2b80c7bf9.png"},45958:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-13-16-25-7818f46ead94d6c9f4947130f472adcf.png"},85513:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-10-03-13-17-38-2bb35826b826841856bb196488dd7a97.png"},16418:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mario-fsm-buffs-d0af36603b4c35c5b73f66ed87b9e63f.png"},10749:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/mario-fsm-6c2b94b9794fdfa0d4d3b8b8ea2ef1cb.png"}}]);