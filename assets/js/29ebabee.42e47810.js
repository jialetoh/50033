"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[2473],{8953:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>m,default:()=>v,frontMatter:()=>c,metadata:()=>d,toc:()=>h});var a=n(7462),o=(n(7294),n(3905)),i=(n(1694),n(6596)),r=n(6533),s=(n(505),n(1496)),l=n(4866),p=n(5162);const c={sidebar_position:2},m="The Observer Pattern",d={unversionedId:"toddlers/observer-pattern",id:"toddlers/observer-pattern",title:"The Observer Pattern",description:"The Observer Pattern is a software design pattern that allows you to create modular game logic that is executed when an event in the game is triggered. It typically works by allowing observers, in this case, other scripts, to subscribe one or more of their own functions to a subject\u2019s event.",source:"@site/docs/03-toddlers/observer-pattern.md",sourceDirName:"03-toddlers",slug:"/toddlers/observer-pattern",permalink:"/50033/docs/toddlers/observer-pattern",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"The Input System",permalink:"/50033/docs/toddlers/management"},next:{title:"Audio Management",permalink:"/50033/docs/toddlers/audio-management"}},u={},h=[{value:"Refactor PlayerMovement",id:"refactor-playermovement",level:2},{value:"UnityEvent",id:"unityevent",level:3},{value:"Detect Mouse Click",id:"detect-mouse-click",level:3},{value:"Why <code>ActionManager.cs</code>?",id:"why-actionmanagercs",level:3},{value:"Be Careful when Changing Method Name",id:"be-careful-when-changing-method-name",level:3},{value:"Delegates",id:"delegates",level:2},{value:"C# Event",id:"c-event",level:3},{value:"UnityEvent",id:"unityevent-1",level:4},{value:"Increase Game Score with Coin",id:"increase-game-score-with-coin",level:3},{value:"Major Refactoring using Events",id:"major-refactoring-using-events",level:3},{value:"Animation Event Tool",id:"animation-event-tool",level:3},{value:"Summary",id:"summary",level:2}],g={toc:h},k="wrapper";function v(e){let{components:t,...c}=e;return(0,o.kt)(k,(0,a.Z)({},g,c,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"the-observer-pattern"},"The Observer Pattern"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://refactoring.guru/design-patterns/observer"},"The Observer Pattern")," is a software design pattern that allows you to create modular game logic that is executed when an event in the game is triggered. It typically works by allowing ",(0,o.kt)("strong",{parentName:"p"},"observers"),", in this case, other ",(0,o.kt)("strong",{parentName:"p"},"scripts"),", to subscribe one or more of their own functions to a subject\u2019s event."),(0,o.kt)("h2",{id:"refactor-playermovement"},"Refactor PlayerMovement"),(0,o.kt)("p",null,"We are now ready to utilise the new input system to control Mario's movement. Let's refactor a few methods in ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerMovement.cs"),". Firstly, take out the code at ",(0,o.kt)("inlineCode",{parentName:"p"},"Update()")," that flips Mario's sprite to face left or right into a new method that takes in an integer. If that integer is ",(0,o.kt)("inlineCode",{parentName:"p"},"-1"),", it means that Mario should face left and we flip the sprite if he's initially facing right, and vice versa. Then, we also refactor ",(0,o.kt)("inlineCode",{parentName:"p"},"FixedUpdate()")," to separate the the logic of moving Mario and making Mario Jump."),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(p.Z,{value:"1",label:"FlipMarioSprite()",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="PlayerMovement.cs"',title:'"PlayerMovement.cs"'},'\n    void Update()\n    {\n        marioAnimator.SetFloat("xSpeed", Mathf.Abs(marioBody.velocity.x));\n    }\n\n//highlight-start\n    void FlipMarioSprite(int value)\n    {\n        if (value == -1 && faceRightState)\n        {\n            faceRightState = false;\n            marioSprite.flipX = true;\n            if (marioBody.velocity.x > 0.05f)\n                marioAnimator.SetTrigger("onSkid");\n\n        }\n\n        else if (value == 1 && !faceRightState)\n        {\n            faceRightState = true;\n            marioSprite.flipX = false;\n            if (marioBody.velocity.x < -0.05f)\n                marioAnimator.SetTrigger("onSkid");\n        }\n    }\n\n    //highlight-end\n'))),(0,o.kt)(p.Z,{value:"2",label:"MoveCheck(int value)",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="PlayerMovement.cs"',title:'"PlayerMovement.cs"'},"//highlight-start\n    private bool moving = false;\n//highlight-end\n    void FixedUpdate()\n    {\n        //highlight-start\n        if (alive && moving)\n        //highlight-end\n        {\n            Move(faceRightState == true ? 1 : -1);\n        }\n    }\n\n//highlight-start\n    void Move(int value)\n    {\n\n        Vector2 movement = new Vector2(value, 0);\n        // check if it doesn't go beyond maxSpeed\n        if (marioBody.velocity.magnitude < maxSpeed)\n            marioBody.AddForce(movement * speed);\n    }\n\n    public void MoveCheck(int value)\n    {\n        if (value == 0)\n        {\n            moving = false;\n        }\n        else\n        {\n            FlipMarioSprite(value);\n            moving = true;\n            Move(value);\n        }\n    }\n    //highlight-end\n\n"))),(0,o.kt)(p.Z,{value:"3",label:"Jump()",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'    private bool jumpedState = false;\n\n    public void Jump()\n    {\n        if (alive && onGroundState)\n        {\n            // jump\n            marioBody.AddForce(Vector2.up * upSpeed, ForceMode2D.Impulse);\n            onGroundState = false;\n            jumpedState = true;\n            // update animator state\n            marioAnimator.SetBool("onGround", onGroundState);\n\n        }\n    }\n\n'))),(0,o.kt)(p.Z,{value:"4",label:"JumpHold()",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"\n    public void JumpHold()\n    {\n        if (alive && jumpedState)\n        {\n            // jump higher\n            marioBody.AddForce(Vector2.up * upSpeed * 30, ForceMode2D.Force);\n            jumpedState = false;\n\n        }\n    }\n\n\n")))),(0,o.kt)("admonition",{type:"important"},(0,o.kt)("p",{parentName:"admonition"},"Notice how ",(0,o.kt)("inlineCode",{parentName:"p"},"MoveCheck"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Jump")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"JumpHold")," are declared as ",(0,o.kt)("inlineCode",{parentName:"p"},"public"),"? That's on purpose. This is because we want to register them with ",(0,o.kt)("inlineCode",{parentName:"p"},"UnityEvent")," later on.")),(0,o.kt)("p",null,"The idea is as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"When ",(0,o.kt)("inlineCode",{parentName:"li"},"move")," action is performed, we want to call ",(0,o.kt)("inlineCode",{parentName:"li"},"Move(value)")," where ",(0,o.kt)("inlineCode",{parentName:"li"},"value")," is 1 or -1 depending on whether Mario is moving to the right of to the left."),(0,o.kt)("li",{parentName:"ol"},"When ",(0,o.kt)("inlineCode",{parentName:"li"},"move")," action is canceled, we want to call ",(0,o.kt)("inlineCode",{parentName:"li"},"Move(0)"))),(0,o.kt)("p",null,"We could do this by ",(0,o.kt)("strong",{parentName:"p"},"referencing")," Mario's PlayerMovement script and call the methods manually, ",(0,o.kt)("strong",{parentName:"p"},"or")," by using ",(0,o.kt)("strong",{parentName:"p"},"Events"),". In particular, we are going to implement the ",(0,o.kt)("strong",{parentName:"p"},"observer pattern")," using ",(0,o.kt)("strong",{parentName:"p"},"UnityEvent"),"."),(0,o.kt)("p",null,"When the event is triggered by the owner or whoever ",(0,o.kt)("inlineCode",{parentName:"p"},"Invoke()")," it, the observers\u2019 functions are called in response. So for instance, when ",(0,o.kt)("inlineCode",{parentName:"p"},"move")," action is cancelled, it will invoke a ",(0,o.kt)("inlineCode",{parentName:"p"},"moveCheck")," Event. Any methods subcribed to ",(0,o.kt)("inlineCode",{parentName:"p"},"moveCheck")," will be called in sequence."),(0,o.kt)("h3",{id:"unityevent"},"UnityEvent"),(0,o.kt)("p",null,"Unity events are a way to hook up function calls between GameObjects in the editor and ",(0,o.kt)("strong",{parentName:"p"},"serialize")," those calls. They are designed to be populated by developer at design-time. Create a new scipt (if you haven't already) called ",(0,o.kt)("inlineCode",{parentName:"p"},"ActionManager.cs")," and attach it to Mario:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'\nusing UnityEngine;\nusing UnityEngine.Events;\nusing UnityEngine.InputSystem;\n\npublic class ActionManager : MonoBehaviour\n{\n    public UnityEvent jump;\n    public UnityEvent jumpHold;\n    public UnityEvent<int> moveCheck;\n\n    public void OnJumpHoldAction(InputAction.CallbackContext context)\n    {\n        if (context.started)\n            Debug.Log("JumpHold was started");\n        else if (context.performed)\n        {\n            Debug.Log("JumpHold was performed");\n            Debug.Log(context.duration);\n            jumpHold.Invoke();\n        }\n        else if (context.canceled)\n            Debug.Log("JumpHold was cancelled");\n    }\n\n    // called twice, when pressed and unpressed\n    public void OnJumpAction(InputAction.CallbackContext context)\n    {\n        if (context.started)\n            Debug.Log("Jump was started");\n        else if (context.performed)\n        {\n            jump.Invoke();\n            Debug.Log("Jump was performed");\n        }\n        else if (context.canceled)\n            Debug.Log("Jump was cancelled");\n\n    }\n\n    // called twice, when pressed and unpressed\n    public void OnMoveAction(InputAction.CallbackContext context)\n    {\n        // Debug.Log("OnMoveAction callback invoked");\n        if (context.started)\n        {\n            Debug.Log("move started");\n            int faceRight = context.ReadValue<float>() > 0 ? 1 : -1;\n            moveCheck.Invoke(faceRight);\n        }\n        if (context.canceled)\n        {\n            Debug.Log("move stopped");\n            moveCheck.Invoke(0);\n        }\n\n    }\n}\n\n')),(0,o.kt)("p",null,"We assume you used ",(0,o.kt)("strong",{parentName:"p"},"Invoke Unity Events")," behavior in ",(0,o.kt)("inlineCode",{parentName:"p"},"Player Input")," component as shown:"),(0,o.kt)(r.Z,{path:n(3535).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,o.kt)("p",null,"Then, ",(0,o.kt)("strong",{parentName:"p"},"serialize")," the three events: Jump, JumpHold, and MoveCheck at the inspector to call the relevant functions in ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerMovement.cs")," script:"),(0,o.kt)(r.Z,{path:n(6429).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,o.kt)("p",null,"Don't forget to use ",(0,o.kt)("strong",{parentName:"p"},"Dynamic")," parameter:"),(0,o.kt)(r.Z,{path:n(9693).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,o.kt)("p",null,"If we did not set ",(0,o.kt)("inlineCode",{parentName:"p"},"MoveCheck")," to be ",(0,o.kt)("strong",{parentName:"p"},"public"),", then we would not be able to select that function from the inspector. What we did above is declare three events that will be ",(0,o.kt)("strong",{parentName:"p"},"invoked")," whenever there's ",(0,o.kt)("strong",{parentName:"p"},"interaction"),". for instance, we call ",(0,o.kt)("inlineCode",{parentName:"p"},"jump.Invoke()")," under ",(0,o.kt)("inlineCode",{parentName:"p"},"OnJumpAction")," callback, but only when ",(0,o.kt)("inlineCode",{parentName:"p"},"context.performed")," is ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),". This will in turn call the method ",(0,o.kt)("inlineCode",{parentName:"p"},"Jump()")," defined in ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerMovement.cs"),"."),(0,o.kt)("p",null,"The method ",(0,o.kt)("inlineCode",{parentName:"p"},"MoveCheck(int value)")," takes in one ",(0,o.kt)("inlineCode",{parentName:"p"},"int")," parameter, and so we need to use UnityEvent with ",(0,o.kt)("strong",{parentName:"p"},"generic")," type, and declare it as ",(0,o.kt)("inlineCode",{parentName:"p"},"public UnityEvent<int> moveCheck"),"."),(0,o.kt)("admonition",{type:"playtest"},(0,o.kt)("p",{parentName:"admonition"},"Save and test that Mario can still move, skid, etc, jump, along with higher jump when you hold the spacebar.")),(0,o.kt)(i.Z,{title:"Deep Dive: UnityEvent vs UnityAction",mdxType:"DeepDive"},"Some of you might have heard about `UnityAction`. They're similar to UnityEvent. Here's an example that will lead into identical results:",(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(p.Z,{value:"1",label:"UnityEvent",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"class Game {\n  public static UnityEvent OnLogin = new UnityEvent();\n}\n\nclass LoginForm {\n  Awake() {\n    Login();\n  }\n\n  private void Login() {\n     Game.OnLogin.Invoke();\n  }\n}\n\nclass Player {\n  Awake() {\n     Game.OnLogin.AddListener(OnLoggedIn);\n  }\n\n  private void OnLoggedIn() {\n    isLogged = true;\n  }\n}\n"))),(0,o.kt)(p.Z,{value:"2",label:"UnityAction",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"class Game {\n  public static UnityAction OnLogin = new delegate {};\n}\n\nclass LoginForm {\n  Awake() {\n    Login();\n  }\n\n  private void Login() {\n     Game.OnLogin();\n  }\n}\n\nclass Player {\n  Awake() {\n     Game.OnLogin += OnLoggedIn;\n  }\n\n  private void OnLoggedIn() {\n    isLogged = true;\n  }\n}\n")))),(0,o.kt)("p",null,"The difference between the two is that ",(0,o.kt)("inlineCode",{parentName:"p"},"UnityEvent")," show up on inspector and you can serialize ",(0,o.kt)("inlineCode",{parentName:"p"},"OnLogin")," there, whereas ",(0,o.kt)("inlineCode",{parentName:"p"},"UnityAction")," must be used solely from script. It comes down to ",(0,o.kt)("em",{parentName:"p"},"style")," choice.")),(0,o.kt)("h3",{id:"detect-mouse-click"},"Detect Mouse Click"),(0,o.kt)("p",null,"Although mouse click is not necessary in Super Mario Bros, let's try to capture the position of a mouse click on the Game screen for the sake of other games that you might create. Firstly, let's rename our control scheme into MarioActions because we no longer ",(0,o.kt)("em",{parentName:"p"},"just")," use the keyboard (it's good to give naming that makes sense). Then, edit the control scheme and add the ",(0,o.kt)("strong",{parentName:"p"},"Mouse")," device."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"If you don't add Mouse into the control scheme, you will not be able to detect mouse clicks!")),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-3/add-mousescheme.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("p",null,"Then as shown in the video above, add an action called ",(0,o.kt)("inlineCode",{parentName:"p"},"click"),' that detects Left Button Mouse press. This alone however is insufficient to capture the "location" of the mouse. We want it to ',(0,o.kt)("strong",{parentName:"p"},"also")," report the location of the mouse click, and for this we need to create a ",(0,o.kt)("strong",{parentName:"p"},"Binding with One Modifier"),". A ",(0,o.kt)("strong",{parentName:"p"},"modifier")," is a condition that has to be held for ",(0,o.kt)("strong",{parentName:"p"},"binding")," to come through. Here we set the action to pass a ",(0,o.kt)("strong",{parentName:"p"},"value")," of control type ",(0,o.kt)("strong",{parentName:"p"},"Vector2"),", the Modifier as the Left Button mouse click, and the Binding as Mouse position."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Please read the documentation about ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/Packages/com.unity.inputsystem@1.6/manual/ActionBindings.html#one-modifier"},"bindings and modifiers here"),".")),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-3/binding-one-modifier.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("p",null,"Now we can define ",(0,o.kt)("strong",{parentName:"p"},"two more")," callbacks in ",(0,o.kt)("inlineCode",{parentName:"p"},"ActionManager.cs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'\n\n    public void OnClickAction(InputAction.CallbackContext context)\n    {\n        if (context.started)\n            Debug.Log("mouse click started");\n        else if (context.performed)\n        {\n            Debug.Log("mouse click performed");\n        }\n        else if (context.canceled)\n            Debug.Log("mouse click cancelled");\n    }\n\n    public void OnPointAction(InputAction.CallbackContext context)\n    {\n        if (context.performed)\n        {\n            Vector2 point = context.ReadValue<Vector2>();\n            Debug.Log($"Point detected: {point}");\n\n        }\n    }\n\n')),(0,o.kt)("admonition",{type:"playtest"},(0,o.kt)("p",{parentName:"admonition"},"Set the callbacks inside Player Input component, and test the mouse clicks in the console:"),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-3/clickmouse.mp4",widthPercentage:"100%",mdxType:"VideoItem"})),(0,o.kt)("h3",{id:"why-actionmanagercs"},"Why ",(0,o.kt)("inlineCode",{parentName:"h3"},"ActionManager.cs"),"?"),(0,o.kt)("p",null,"Can we implement the input system callbacks directly at ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerMovement.cs"),"? Yes, sure we can. It comes down to preference and principle: do you prefer separating the scripts between managing your actions state (deciding what to do depending on the ",(0,o.kt)("inlineCode",{parentName:"p"},"context")," state) and ",(0,o.kt)("strong",{parentName:"p"},"implementing")," the game logic (deciding ",(0,o.kt)("strong",{parentName:"p"},"how")," to jump)? There's no right answer to any of this."),(0,o.kt)("h3",{id:"be-careful-when-changing-method-name"},"Be Careful when Changing Method Name"),(0,o.kt)("p",null,"If you happen to refactor your code and ",(0,o.kt)("strong",{parentName:"p"},"change")," the method name, e.g: ",(0,o.kt)("inlineCode",{parentName:"p"},"onJumpHoldAction")," into ",(0,o.kt)("inlineCode",{parentName:"p"},"OnJumpHoldAction"),", whatever you have set on the inspector ",(0,o.kt)("span",{className:"orange-bold"},"will not")," change with it. It will be written as ",(0,o.kt)("strong",{parentName:"p"},"missing"),":"),(0,o.kt)(r.Z,{path:n(6561).Z,widthPercentage:"50%",mdxType:"ImageCard"}),(0,o.kt)("p",null,"You have to fix it too in the inspector. This is very tedious, but so is creating everything via script. It's a give and take."),(0,o.kt)("h2",{id:"delegates"},"Delegates"),(0,o.kt)("p",null,"We used ",(0,o.kt)("inlineCode",{parentName:"p"},"UnityEvent")," above as some kind of ",(0,o.kt)("strong",{parentName:"p"},"function container")," that we can ",(0,o.kt)("inlineCode",{parentName:"p"},"Invoke()")," and then it will call all functions subcribed to it ",(0,o.kt)("em",{parentName:"p"},"in order"),". We don't really see it in the example above because we only have ",(0,o.kt)("strong",{parentName:"p"},"one")," function subscribed to it as defined in the Inspector. Let's dive deeper into how it works."),(0,o.kt)("admonition",{title:"Delegate",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"A delegate is a reference pointer to a method. It allows us to treat method as a variable and pass method as a variable for a callback. When a delegate gets called, it notifies all methods that reference the delegate."),(0,o.kt)("p",{parentName:"admonition"},"The basic idea behind them is exactly the same as a subscription magazine. Anyone can subscribe to the service and they will receive the update at the right time automatically.")),(0,o.kt)("p",null,"You can declare a delegate with the delegate keyword and specifies its signature (return type and parameters):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"public delegate returnType MethodName (paramType1 paramName1, paramType2 paramName2, ...);\n")),(0,o.kt)("p",null,"For example, something like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"public delegate void SimpleGameEvent();\n")),(0,o.kt)("h3",{id:"c-event"},"C# Event"),(0,o.kt)("p",null,"To allow other scripts to subscribe to this delegate, we need to create an instance of that delegate, using the ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," keyword:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"public static event SimpleGameEvent IncreaseScore;\n")),(0,o.kt)("p",null,"We can also use the delegate directly using its name without the ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," keyword:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"public static SimpleGameEvent IncreaseScore;\n")),(0,o.kt)("admonition",{title:"event keyword",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Without the ",(0,o.kt)("inlineCode",{parentName:"p"},"event")," keyword, ",(0,o.kt)("inlineCode",{parentName:"p"},"IncreaseScore")," can be cast by anyone (unless it is not public, but that will mean that not every other script can subscribe to it). If we want ",(0,o.kt)("span",{className:"orange-bold"},"only")," the ",(0,o.kt)("strong",{parentName:"p"},"owner")," of the ",(0,o.kt)("strong",{parentName:"p"},"delegate")," to cast, then the event keyword is used.")),(0,o.kt)("p",null,"Since the event is declared as ",(0,o.kt)("inlineCode",{parentName:"p"},"static"),", that means other scripts can subscribe to it via the Classname."),(0,o.kt)("h4",{id:"unityevent-1"},"UnityEvent"),(0,o.kt)("p",null,"We will ",(0,o.kt)("strong",{parentName:"p"},"mainly")," utilise ",(0,o.kt)("inlineCode",{parentName:"p"},"UnityEvent")," instead of C# Event and delegates because the former allows us to conveniently set it up via the inspector and that it covers basic signatures that we need (return type of ",(0,o.kt)("inlineCode",{parentName:"p"},"void")," and accept generic parameters, up to four)."),(0,o.kt)("h3",{id:"increase-game-score-with-coin"},"Increase Game Score with Coin"),(0,o.kt)("p",null,"When Mario touches a box or brick with Coin, we are supposed to increase the game score. Right now the ",(0,o.kt)("inlineCode",{parentName:"p"},"score")," state is stored in ",(0,o.kt)("inlineCode",{parentName:"p"},"JumpOverGoomba"),". ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerMovement")," ",(0,o.kt)("strong",{parentName:"p"},"has")," to reference this script in order to change its ",(0,o.kt)("inlineCode",{parentName:"p"},"score")," during restart:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="PlayerMovement.cs"',title:'"PlayerMovement.cs"'},'\n    public void ResetGame()\n    {\n        // ... other instructions\n\n        // reset Goomba\n        foreach (Transform eachChild in enemies.transform)\n        {\n            eachChild.localPosition = eachChild.GetComponent<EnemyMovement>().startPosition;\n        }\n\n        //highlight-start\n        // reset score\n        jumpOverGoomba.score = 0;\n//highlight-end\n\n        // reset animation\n        marioAnimator.SetTrigger("gameRestart");\n        alive = true;\n\n        // reset camera position\n        gameCamera.position = new Vector3(0, 0, -10);\n    }\n\n')),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"ScoreText")," is also modified by three scripts separately: ",(0,o.kt)("inlineCode",{parentName:"p"},"GameManager"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"JumpOverGoomba"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"PlayerMovement"),". Here's a graph that illustrates referencing between scripts/GameObjects:"),(0,o.kt)("mermaid",{value:"flowchart TD\n    ST(ScoreText)\n    PM(PlayerMovement)\n    JG(JumpOverGoomba)\n    GM(GameManager)\n    GO(GameOverPanel)\n    RB(RestartButton)\n    PM--\x3e|resets|ST\n    JG--\x3e|updates|ST\n    GM--\x3e|sets transform|ST\n    GM--\x3e|sets transform|RB\n    GM--\x3e|toggles|GO\n    PM--\x3e|resets score|JG\n    PM--\x3e|sets GameOver|GM\n    GM--\x3e|restarts|PM\n    RB--\x3e|restarts|GM"}),(0,o.kt)("p",null,"It's pretty messy right now:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"ScoreText is referenced by ",(0,o.kt)("strong",{parentName:"li"},"three")," different scripts"),(0,o.kt)("li",{parentName:"ul"},"PlayerMovement and GameManager controls each other"),(0,o.kt)("li",{parentName:"ul"},'GameManager does not "manage" the game: score is stored inside JumpOverGoomba')),(0,o.kt)("p",null,"Let's fix it to something neater as follows:"),(0,o.kt)("mermaid",{value:"flowchart TD\n    JG(JumpOverGoomba)\n    PM(PlayerMovement)\n    ST(ScoreText)\n    GM(GameManager<br>score)\n    GO(GameOverPanel)\n    RB(RestartButton)\n    GOOM(Goomba)\n    JG--\x3e|increases|GM\n    GM--\x3e|restarts|PM\n    GM--\x3e|restarts|ST\n    GM--\x3e|restarts|GOOM\n    GM--\x3e|updates|ST\n    PM--\x3e|sets GameOver|GM\n    GM--\x3e|sets GameOver|ST\n    GM--\x3e|sets GameOver|RB\n    GM--\x3e|toggles<br>GameOver, GameRestart|GO\n    RB--\x3e|restarts|GM"}),(0,o.kt)("h3",{id:"major-refactoring-using-events"},"Major Refactoring using Events"),(0,o.kt)("p",null,"We need to create ",(0,o.kt)("strong",{parentName:"p"},"three")," different ",(0,o.kt)("strong",{parentName:"p"},"events"),": ",(0,o.kt)("inlineCode",{parentName:"p"},"GameOver"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"GameStart"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"GameRestart"),", and ",(0,o.kt)("inlineCode",{parentName:"p"},"ScoreChange")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"GameManager.cs")," and let other scripts subscribe to it and update themselves accordingly. Create ",(0,o.kt)("strong",{parentName:"p"},"two")," new scripts: ",(0,o.kt)("inlineCode",{parentName:"p"},"HUDManager.cs")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"EnemyManager.cs")," which will contain callbacks to subscribe to the events above:"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"Do not ",(0,o.kt)("span",{className:"orange-bold"},"blindly")," copy paste the content of the methods below. Your actual implementation might vary, for instance you might not have the ",(0,o.kt)("inlineCode",{parentName:"p"},"GameOverPanel")," in your implementation if you did not choose to do it for Checkoff 1. These files are for your reference only.")),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(p.Z,{value:"3",label:"HUDManager.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing TMPro;\n\npublic class HUDManager : MonoBehaviour\n{\n    private Vector3[] scoreTextPosition = {\n        new Vector3(-747, 473, 0),\n        new Vector3(0, 0, 0)\n        };\n    private Vector3[] restartButtonPosition = {\n        new Vector3(844, 455, 0),\n        new Vector3(0, -150, 0)\n    };\n\n    public GameObject scoreText;\n    public Transform restartButton;\n\n    public GameObject gameOverPanel;\n    // Start is called before the first frame update\n    void Start()\n    {\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n\n    }\n\n    public void GameStart()\n    {\n        // hide gameover panel\n        gameOverPanel.SetActive(false);\n        scoreText.transform.localPosition = scoreTextPosition[0];\n        restartButton.localPosition = restartButtonPosition[0];\n    }\n\n    public void SetScore(int score)\n    {\n        scoreText.GetComponent<TextMeshProUGUI>().text = "Score: " + score.ToString();\n    }\n\n\n    public void GameOver()\n    {\n        gameOverPanel.SetActive(true);\n        scoreText.transform.localPosition = scoreTextPosition[1];\n        restartButton.localPosition = restartButtonPosition[1];\n    }\n}\n\n'))),(0,o.kt)(p.Z,{value:"4",label:"EnemyManager.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class EnemyManager : MonoBehaviour\n{\n    // Start is called before the first frame update\n    void Start()\n    {\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n\n    }\n\n    public void GameRestart()\n    {\n        foreach (Transform child in transform)\n        {\n            child.GetComponent<EnemyMovementWeek3>().GameRestart();\n        }\n    }\n}\n\n")))),(0,o.kt)("p",null,"Then modify these existing files such that we no longer have to refer to ",(0,o.kt)("strong",{parentName:"p"},"scripts")," in inspector and we don't store ",(0,o.kt)("inlineCode",{parentName:"p"},"score")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"JumpOverGoomba.cs"),":"),(0,o.kt)(l.Z,{mdxType:"Tabs"},(0,o.kt)(p.Z,{value:"1",label:"GameManager.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class GameManagerWeek3 : MonoBehaviour\n{\n    // events\n    public UnityEvent gameStart;\n    public UnityEvent gameRestart;\n    public UnityEvent<int> scoreChange;\n    public UnityEvent gameOver;\n\n    private int score = 0;\n\n    void Start()\n    {\n        gameStart.Invoke();\n        Time.timeScale = 1.0f;\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n\n    }\n\n    public void GameRestart()\n    {\n        // reset score\n        score = 0;\n        SetScore(score);\n        gameRestart.Invoke();\n        Time.timeScale = 1.0f;\n    }\n\n    public void IncreaseScore(int increment)\n    {\n        score += increment;\n        SetScore(score);\n    }\n\n    public void SetScore(int score)\n    {\n        scoreChange.Invoke(score);\n    }\n\n\n    public void GameOver()\n    {\n        Time.timeScale = 0.0f;\n        gameOver.Invoke();\n    }\n}\n"))),(0,o.kt)(p.Z,{value:"2",label:"PlayerMovement.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'    public void GameRestart()\n    {\n        // reset position\n        marioBody.transform.position = new Vector3(-5.33f, -4.69f, 0.0f);\n        // reset sprite direction\n        faceRightState = true;\n        marioSprite.flipX = false;\n\n        // reset animation\n        marioAnimator.SetTrigger("gameRestart");\n        alive = true;\n\n        // reset camera position\n        gameCamera.position = new Vector3(0, 0, -10);\n    }\n'))),(0,o.kt)(p.Z,{value:"5",label:"JumpOverGoomba.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'    //highlight-start\n    GameManager gameManager;\n//highlight-end\n    void Start(){\n        //highlight-start\n        gameManager = GameObject.FindGameObjectWithTag("Manager").GetComponent<GameManager>();\n        //highlight-end\n    }\n\n    void FixedUpdate()\n    {\n        // when jumping, and Goomba is near Mario and we haven\'t registered our score\n        if (!onGroundState && countScoreState)\n        {\n            if (Mathf.Abs(transform.position.x - enemyLocation.position.x) < 0.5f)\n            {\n                countScoreState = false;\n                //highlight-start\n                gameManager.IncreaseScore(1); //\n                //highlight-end\n            }\n        }\n\n    }\n\n'))),(0,o.kt)(p.Z,{value:"6",label:"EnemyMovement.cs",mdxType:"TabItem"},(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"\n    public void GameRestart()\n    {\n        transform.localPosition = startPosition;\n        originalX = transform.position.x;\n        moveRight = -1;\n        ComputeVelocity();\n    }\n\n")))),(0,o.kt)("admonition",{title:"important",type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"There are many things to do, but the big idea is that we need to:"),(0,o.kt)("ol",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Remove")," storing score at ",(0,o.kt)("inlineCode",{parentName:"li"},"JumpOverGoomba.cs")),(0,o.kt)("li",{parentName:"ol"},"Remove ",(0,o.kt)("strong",{parentName:"li"},"script")," references in inspector except to ",(0,o.kt)("inlineCode",{parentName:"li"},"GameManager.cs")," (see video below)"))),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-3/setup-events.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("admonition",{type:"playtest"},(0,o.kt)("p",{parentName:"admonition"},"Your actual implementation may vary a little, such as the game restart and gameover scene that is part of Checkoff 1.")),(0,o.kt)("h3",{id:"animation-event-tool"},"Animation Event Tool"),(0,o.kt)("p",null,"Now that we have refactored everything to utilise Events as much as possible and removing direct references to scripts, we can register a ",(0,o.kt)("strong",{parentName:"p"},"callback")," via AnimationEvent when a coin spawn is triggered. Specifically, we want to call the ",(0,o.kt)("inlineCode",{parentName:"p"},"IncreaseScore(1)")," method inside GameManager instance."),(0,o.kt)("admonition",{type:"caution"},(0,o.kt)("p",{parentName:"admonition"},"Recall that AnimationEvent will only list out public methods with signature: return type ",(0,o.kt)("inlineCode",{parentName:"p"},"void")," and zero argument only from scripts attached to that GameObject where the Animator component is? That means it will ",(0,o.kt)("span",{className:"orange-bold"},"not")," detect IncreaseScore method since that method is within GameManager and not Coin.")),(0,o.kt)("p",null,"To help us, we shall create a ",(0,o.kt)("strong",{parentName:"p"},"helper")," script. We name it ",(0,o.kt)("inlineCode",{parentName:"p"},"AnimationEventIntTool.cs"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="AnimationEventIntTool.cs"',title:'"AnimationEventIntTool.cs"'},"using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing UnityEngine.Events;\n\npublic class AnimationEventIntTool : MonoBehaviour\n{\n    public int parameter;\n    public UnityEvent<int> useInt;\n    // Start is called before the first frame update\n    void Start()\n    {\n\n    }\n\n    // Update is called once per frame\n    void Update()\n    {\n\n    }\n\n    public void TriggerIntEvent()\n    {\n\n        useInt.Invoke(parameter); // safe to invoke even without callbacks\n\n    }\n}\n")),(0,o.kt)("p",null,"Usage steps:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Attach the ",(0,o.kt)("inlineCode",{parentName:"li"},"AnimationEventIntTool.cs")," to ",(0,o.kt)("strong",{parentName:"li"},"all")," coins.",(0,o.kt)(r.Z,{path:n(2278).Z,widthPercentage:"70%",mdxType:"ImageCard"})),(0,o.kt)("li",{parentName:"ol"},"Then for all coins, modify its animation clip to trigger events at the end of it.",(0,o.kt)(r.Z,{path:n(5309).Z,widthPercentage:"70%",mdxType:"ImageCard"})),(0,o.kt)("li",{parentName:"ol"},"Link up GameManager ",(0,o.kt)("strong",{parentName:"li"},"instance")," of this Scene to get the ",(0,o.kt)("inlineCode",{parentName:"li"},"IncreaseScore(int score)")," callback at the inspector")),(0,o.kt)("p",null,"In our demo below, we have two events (but you might just have this one, it's fine). Make sure you set it to call all your events from all scripts attached to the Coin."),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-3/setup-callback-coin.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("admonition",{title:"Setting Prefab value with Instance",type:"danger"},(0,o.kt)("p",{parentName:"admonition"},"In the beginning, we set GameManager's IncreaseScore into all Coin script, but we seem to have to do it again at 1:09. This is because we ",(0,o.kt)("strong",{parentName:"p"},"apply")," the changes to ALL question-box-coin prefab at 00:42."),(0,o.kt)("p",{parentName:"admonition"},"GameManager IncreaseScore is a Scene ",(0,o.kt)("strong",{parentName:"p"},"instance"),", meaning that it does ",(0,o.kt)("em",{parentName:"p"},"not persist"),". A prefab cannot refer to a script instance from another GameObjects that is ",(0,o.kt)("span",{className:"orange-bold"},"NOT")," part of the prefab, because it wouldn't know if that instance will exist in the scene that it's currently spawned at (yes, we can instantiate prefabs at any scene at runtime). That's why the blue line indicator besides all the prefab in the Hierarchy does not disappear even after we apply the changes to all prefabs:"),(0,o.kt)(r.Z,{path:n(5095).Z,widthPercentage:"50%",mdxType:"ImageCard"}),(0,o.kt)("p",{parentName:"admonition"},"We also need to manually set ALL coins to call IncreaseScore from this scene's GameManager instance, as you see in the beginning of the video or at 1:09.")),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"We have seen how convenient it is to set callbacks via the inspector. However, if our callbacks come from another GameObject instance that's not part of the prefab's, then we would have to do that each time we instantiate a prefab."),(0,o.kt)("p",null,'Setting things up from the inspector (as opposed to from the script) can be a double-edged sword. On one hand: it is convenient and visually affirming, while on the other hand: it is easy to miss a few things or "forgot" to set it up.'))}v.isMDXComponent=!0},3535:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-08-11-16-08-44-a7ee5dad3d12d8f01d5a249284e3ed88.png"},6429:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-08-11-16-09-48-86f98058d9f1fa5810bcce018b4d7487.png"},9693:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-08-11-16-10-15-93a7490d05aebb6c01ce30af9fbc3b21.png"},6561:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-08-11-17-45-00-09ad350adf590240c7c73a1a4d046c7b.png"},2278:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-08-16-09-26-20-77959be63f1374916f00525d9c9b3126.png"},5309:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-08-16-09-26-42-ea61b20f4fa4d085b777aad84f69d275.png"},5095:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-08-16-09-31-02-ad84e8fa88631fbc352d202edcd70e8d.png"}}]);