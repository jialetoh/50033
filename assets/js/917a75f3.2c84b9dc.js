"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[7564],{3005:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>p,toc:()=>c});var a=n(7462),o=(n(7294),n(3905)),i=(n(1694),n(6596),n(6533)),s=(n(505),n(1496));n(4866),n(5162);const r={sidebar_position:4},l="Polishing with Coroutines",p={unversionedId:"children/coroutines",id:"children/coroutines",title:"Polishing with Coroutines",description:"To polish our game further, we need to ensure that:",source:"@site/docs/04-children/coroutines.md",sourceDirName:"04-children",slug:"/children/coroutines",permalink:"/50033/docs/children/coroutines",draft:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Scriptable Objects",permalink:"/50033/docs/children/scriptableobjects"},next:{title:"Checkoff",permalink:"/50033/docs/children/checkoff"}},u={},c=[{value:"C#: Coroutines",id:"c-coroutines",level:2},{value:"Basic Idea",id:"basic-idea",level:4},{value:"Examples",id:"examples",level:3},{value:"Health Replenish UI",id:"health-replenish-ui",level:4},{value:"Temporary Invincibility",id:"temporary-invincibility",level:4},{value:"Fading Loading Screen",id:"fading-loading-screen",level:4},{value:"<code>yield return</code>",id:"yield-return",level:3},{value:"Waiting for a Coroutine to Finish",id:"waiting-for-a-coroutine-to-finish",level:4},{value:"Starting Multiple Coroutines",id:"starting-multiple-coroutines",level:3},{value:"Stopping Coroutines",id:"stopping-coroutines",level:3},{value:"C#: Async Methods and Multithreading With Task",id:"async-methods",level:2},{value:"Vanilla Method",id:"vanilla-method",level:4},{value:"Coroutine",id:"coroutine",level:4},{value:"Async &amp; Await with Task",id:"async--await-with-task",level:4},{value:"Comparison With Coroutine",id:"comparison-with-coroutine",level:2},{value:"Async Functions Always Complete",id:"async-functions-always-complete",level:3},{value:"Memory Leak With Coroutine",id:"memory-leak-with-coroutine",level:4},{value:"Stopping Async Functions",id:"stopping-async-functions",level:3},{value:"Return Values",id:"return-values",level:3},{value:"Summary",id:"summary",level:2},{value:"Fix The Powerup Bug",id:"powerup-bug",level:2}],m={toc:c},d="wrapper";function h(e){let{components:t,...r}=e;return(0,o.kt)(d,(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"polishing-with-coroutines"},"Polishing with Coroutines"),(0,o.kt)("p",null,"To polish our game further, we need to ensure that:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"All player actions constitute a reaction"),(0,o.kt)("li",{parentName:"ol"},"The UI is coherent"),(0,o.kt)("li",{parentName:"ol"},"There exist a main menu to properly start a game"),(0,o.kt)("li",{parentName:"ol"},"Restart and pausing capability works as intended"),(0,o.kt)("li",{parentName:"ol"},"There exist some modularity in the code structure of the game, for instance: powerups")),(0,o.kt)("p",null,"What we have learned so far: animation, sound management, input system, scriptable objects, singleton pattern, and asset management are more than sufficient to polish the game. But another aspect of polishing that we want to have in our game is ",(0,o.kt)("span",{className:"orange-bold"},"responsiveness"),"."),(0,o.kt)("p",null,"In certain situations, we might want to spread a sequence of events like procedural animations over time. We can utilise ",(0,o.kt)("strong",{parentName:"p"},"coroutines")," for this."),(0,o.kt)("h2",{id:"c-coroutines"},"C#: Coroutines"),(0,o.kt)("p",null,"A coroutine lets us to spread tasks across several ",(0,o.kt)("strong",{parentName:"p"},"frames"),". It pauses execution and return control to Unity, and then continue where it left off on the following ",(0,o.kt)("span",{className:"orange-bold"},"frame"),". A normal function like ",(0,o.kt)("inlineCode",{parentName:"p"},"Update()")," cannot do this and must run into completion before returning control to Unity."),(0,o.kt)("p",null,"Coroutines are very ",(0,o.kt)("span",{className:"orange-bold"},"resource efficient")," so it's okay to use them for your projects."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"It is important to understand that Coroutines are ",(0,o.kt)("span",{className:"orange-bold"},"not")," threads. Synchronous operations that run within coroutines are still executed on Unity main thread. Do ",(0,o.kt)("span",{className:"orange-bold"},"not")," use blocking operation in a coroutine. If you want to use threads for consuming an ",(0,o.kt)("inlineCode",{parentName:"p"},"HTTP")," request, for example, you can use ",(0,o.kt)("a",{parentName:"p",href:"#async-methods"},"async methods")," instead.")),(0,o.kt)("p",null,"You can declare and call Coroutine like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"    IEnumerator  functionName(){\n        // implementation here\n        // typically contain a yield return statement\n    }\n\n    void UseCoroutine()\n    {\n        // call it\n        StartCoroutine(functionName());\n        // do other things (can be done immediately after coroutine yields)\n    }\n")),(0,o.kt)("h4",{id:"basic-idea"},"Basic Idea"),(0,o.kt)("p",null,"When you start a coroutine using ",(0,o.kt)("inlineCode",{parentName:"p"},"StartCoroutine"),", the coroutine runs on the Unity main thread, just like the rest of your game code. It ",(0,o.kt)("span",{className:"orange-bold"},"doesn't block")," the execution of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Update")," or other functions in your script. You also ",(0,o.kt)("span",{className:"orange-bold"},"don't need to wait for the coroutine to finish")," before the Update function or other Unity event functions are called as per normal."),(0,o.kt)("p",null,"The Unity main thread continues to execute other code and events while the coroutine is running in the background. The coroutine itself will ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," control back to the main thread when it encounters a ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," statement, such as yield return new ",(0,o.kt)("inlineCode",{parentName:"p"},"WaitForSecondsRealtime(time)")," (see later section), allowing other code to run during the specified time delay ",(0,o.kt)("span",{className:"orange-bold"},"without freezing")," the entire game. Once the time delay is over, the coroutine resumes its execution."),(0,o.kt)("p",null,"In short, you can think of coroutines in Unity as a way to perform tasks over time or in the background without blocking the main thread and the normal execution of Unity's event functions like ",(0,o.kt)("inlineCode",{parentName:"p"},"Update"),"."),(0,o.kt)("h3",{id:"examples"},"Examples"),(0,o.kt)("h4",{id:"health-replenish-ui"},"Health Replenish UI"),(0,o.kt)("p",null,"One example of procedural animation is gradually increasing the health bar over time (e.g: after drinking a potion, etc):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="HealthBar.cs"',title:'"HealthBar.cs"'},"using System.Collections;\nusing UnityEngine;\n\npublic class HealthBar : MonoBehaviour\n{\n   // an SO instance containing hp\n   public IntVar playerHP;\n\n   public void RefillHealth(int amount)\n   {\n       StartCoroutine(HealthIncrease(amount));\n   }\n\n   IEnumerator HealthIncrease(float amount){\n       for(int x=1; x <= amount && playerHP.Value <= playerHP.maxValue >; x++){\n           playerHP.Value += x;\n           GameManager.instance.UpdateUI(); // calls for update\n           yield return new WaitForSeconds(0.2f);\n       }\n   }\n}\n")),(0,o.kt)("h4",{id:"temporary-invincibility"},"Temporary Invincibility"),(0,o.kt)("p",null,"For those making casual (chaotic) couch multiplayer game, you will also want to use coroutines to prevent the same player to be hit again after 0.5 seconds. This will create temporary invincibility to avoid an unjust game experience. We would deactivate the player's hitbox or some ",(0,o.kt)("inlineCode",{parentName:"p"},"vulnerable")," state for 0.5 seconds before enabling it again."),(0,o.kt)("h4",{id:"fading-loading-screen"},"Fading Loading Screen"),(0,o.kt)("p",null,"Another example is to fade UI elements in the loading scene right before game starts:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="LoadAndWait.cs"',title:'"LoadAndWait.cs"'},'using UnityEngine;\nusing UnityEngine.SceneManagement;\n\npublic class LoadAndWait : MonoBehaviour\n{\n    public CanvasGroup c;\n\n    void Start()\n    {\n        StartCoroutine(Fade());\n    }\n    IEnumerator Fade()\n    {\n        for (float alpha = 1f; alpha >= -0.05f; alpha -= 0.05f)\n        {\n            c.alpha = alpha;\n            yield return new WaitForSecondsRealtime(0.1f);\n        }\n\n        // once done, go to next scene\n        SceneManager.LoadSceneAsync("World-1-1", LoadSceneMode.Single);\n    }\n\n    public void ReturnToMain()\n    {\n        // TODO\n        Debug.Log("Return to main menu");\n    }\n}\n\n')),(0,o.kt)("p",null,"We can tryout ",(0,o.kt)("inlineCode",{parentName:"p"},"Fade")," above by creating another scene called ",(0,o.kt)("inlineCode",{parentName:"p"},"LoadingScene")," with the following configuration. Feel free to create a Main Menu as well."),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-4/fadescene.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("admonition",{title:"highlight on hover button",type:"note"},(0,o.kt)("p",{parentName:"admonition"},"It's common to highlight a button by showing some image beside it, like the mushroom cursor on SuperMarioBros main menu. To do this, simply set the ",(0,o.kt)("inlineCode",{parentName:"p"},"Normal Color")," of a button to have an alpha value of 0, and its ",(0,o.kt)("inlineCode",{parentName:"p"},"Highlighted Color")," to have an alpha value of 1."),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-4/hover-highlight-button.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("p",{parentName:"admonition"},'When you select a button on the UI, the button will remain "selected" even after you have finished clicking. In order to "reset" the button state, add the following instructions in the callback of that button (e.g: we want to reset highscore but not leave the button in the state of "pressed" after highscore is reset):'),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'        GameObject eventSystem = GameObject.Find("EventSystem");\n        eventSystem.GetComponent<UnityEngine.EventSystems.EventSystem>().SetSelectedGameObject(null);\n')),(0,o.kt)("p",{parentName:"admonition"},"This is what the ",(0,o.kt)("inlineCode",{parentName:"p"},"EventSystem")," GameObject in your scene is for, which is to manage events of mouse clicks and keyboard presses to interact with the UI elements (automatically created when you added your first UI Element GameObject to your scene).")),(0,o.kt)("br",null),(0,o.kt)("h3",{id:"yield-return"},(0,o.kt)("inlineCode",{parentName:"h3"},"yield return")),(0,o.kt)("p",null,"On a coroutine, the yield return ",(0,o.kt)("inlineCode",{parentName:"p"},"[something]")," returns control to Unity until that ",(0,o.kt)("inlineCode",{parentName:"p"},"[something]")," condition is fulfilled. If we do ",(0,o.kt)("inlineCode",{parentName:"p"},"yield return null"),", your coroutine code ",(0,o.kt)("span",{className:"orange-bold"},"pauses")," for the next frame and ",(0,o.kt)("strong",{parentName:"p"},"continues")," where it left off (after the ",(0,o.kt)("inlineCode",{parentName:"p"},"yield return"),") afterward, depending on whether that ",(0,o.kt)("inlineCode",{parentName:"p"},"[something]")," condition is fulfilled. That ",(0,o.kt)("inlineCode",{parentName:"p"},"[something]")," can be also be any of the things below:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/ScriptReference/WaitForSeconds.html"},"Wait for a few seconds")," (scaled): ",(0,o.kt)("inlineCode",{parentName:"li"},"yield return new WaitForSeconds(0.1f)")),(0,o.kt)("li",{parentName:"ol"},"Wait for a few seconds (",(0,o.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/ScriptReference/WaitForSecondsRealtime.html"},"realtime"),"): ",(0,o.kt)("inlineCode",{parentName:"li"},"yield return new WaitForSecondsRealtime(0.1f)")),(0,o.kt)("li",{parentName:"ol"},"Wait until ",(0,o.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/ScriptReference/WaitForFixedUpdate.html"},"next fixed update frame")," or ",(0,o.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/ScriptReference/WaitForEndOfFrame.html"},"until end of frame"),":",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"yield return new WaitForEndOfFrame()")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"yield return new WaitForFixedUpdate()")))),(0,o.kt)("li",{parentName:"ol"},"Wait until a certain ",(0,o.kt)("em",{parentName:"li"},"delegate")," value is ",(0,o.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/ScriptReference/WaitUntil.html"},"true")," or ",(0,o.kt)("a",{parentName:"li",href:"https://docs.unity3d.com/ScriptReference/WaitWhile.html"},"false"),(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"yield return new WaitUntil(() => some_value > some_condition)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"yield return new WaitWhile(() => some_value < some_condition)"))))),(0,o.kt)("p",null,"The example below illustrates the behavior using ",(0,o.kt)("inlineCode",{parentName:"p"},"WaitForSecondsRealtime"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:"showLineNumbers",showLineNumbers:!0},'using System.Collections;\nusing UnityEngine;\n\npublic class Coroutines : MonoBehaviour\n{\n\n   void Start(){\n       Debug.Log("Begin Start event");\n       StartCoroutine(WaitCoroutine(2f));\n       Debug.Log("End Start event");\n   }\n\n   private IEnumerator WaitCoroutine(float time){\n       Debug.Log("Inside coroutine");\n       yield return new WaitForSecondsRealtime(time);\n       Debug.Log("Finish coroutine after "+time+" seconds");\n   }\n}\n\n// Printed output:\n//\n// Begin Start event\n// Inside coroutine\n// End Start event\n// Finish coroutine after 2 seconds\n')),(0,o.kt)("p",null,"The order of execution of the code at first begin as per normal: line 8, 9, then line 14, and 15. When ",(0,o.kt)("inlineCode",{parentName:"p"},"yield return")," statement is met, we return control to Unity first (hence line 10 is executed). Two seconds later, line 16 is then executed."),(0,o.kt)("p",null,"Here's another example using ",(0,o.kt)("inlineCode",{parentName:"p"},"WaitWhile")," (taken from ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/ScriptReference/WaitWhile.html"},"Unity official documentation"),"):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:"showLineNumbers",showLineNumbers:!0},'using UnityEngine;\nusing System.Collections;\n\npublic class WaitWhileExample : MonoBehaviour\n{\n    public int enemies = 10; // we assume something else is reducing this value, one per second\n\n    void Start()\n    {\n        Debug.Log("Begin rescue mission");\n        StartCoroutine(Rescue("Toad"));\n        Debug.Log("Rescue mission started");\n    }\n\n    IEnumerator Rescue(string name)\n    {\n        Debug.Log($"Waiting for Mario to rescue {name}...");\n        yield return new WaitWhile(() => enemies > 0);\n        Debug.Log($"Finally, all enemies are eliminated and {name} have been rescued!");\n    }\n\n}\n\n// Printed output:\n//\n// Begin rescue mission\n// Waiting for Mario to rescue Toad...\n// Rescue mission started\n// Finally, all enemies are eliminated and I have been rescued!\n')),(0,o.kt)("admonition",{type:"important"},(0,o.kt)("p",{parentName:"admonition"},"When you start a coroutine using ",(0,o.kt)("inlineCode",{parentName:"p"},"StartCoroutine"),", it doesn't block the execution of the calling method (in the above case, ",(0,o.kt)("inlineCode",{parentName:"p"},"Start"),"). The coroutine runs ",(0,o.kt)("em",{parentName:"p"},"separately")," in the background, and the calling method continues to execute immediately after starting the coroutine."),(0,o.kt)("p",{parentName:"admonition"},"Remember that Unity coroutines are not executed on separate threads. They run on the Unity main thread, just like the rest of your Unity game code. Coroutine provides a way to perform asynchronous-like operations ",(0,o.kt)("span",{className:"orange-bold"},"without")," introducing threading complexities.")),(0,o.kt)("h4",{id:"waiting-for-a-coroutine-to-finish"},"Waiting for a Coroutine to Finish"),(0,o.kt)("p",null,"If you have a very specific case such as to wait for Coroutine launched in a ",(0,o.kt)("inlineCode",{parentName:"p"},"Start")," function ",(0,o.kt)("em",{parentName:"p"},"before")," the ",(0,o.kt)("inlineCode",{parentName:"p"},"Update")," function is launched, then you need to use some kind of ",(0,o.kt)("inlineCode",{parentName:"p"},"flag")," to make this happen, for instance:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'using System.Collections;\nusing UnityEngine;\n\npublic class SomeScript : MonoBehaviour\n{\n    private bool isStartComplete = false;\n\n    void Start()\n    {\n        Debug.Log("Begin Start event");\n        StartCoroutine(StartEventCoroutine());\n        Debug.Log("Start Invoked");\n    }\n\n    private IEnumerator StartEventCoroutine()\n    {\n        // Perform any initialization or tasks you need in Start here.\n        // ...\n\n        // Assume you want to delay for 2 seconds before Update() works\n        yield return new WaitForSeconds(2f);\n\n        // Mark the Start as complete.\n        isStartComplete = true;\n    }\n\n    void Update()\n    {\n        // Only execute Update when StartEventCoroutine completes\n        if (isStartComplete)\n        {\n            // Your Update code here.\n            // ...\n        }\n    }\n}\n')),(0,o.kt)("h3",{id:"starting-multiple-coroutines"},"Starting Multiple Coroutines"),(0,o.kt)("p",null,"You can also start many coroutines at once, such as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'    void Start()\n    {\n        Debug.Log("Begin rescue mission");\n        StartCoroutine(Rescue("Toad"));\n        StartCoroutine(Rescue("Peach"));\n        Debug.Log("Rescue mission started");\n    }\n')),(0,o.kt)("p",null,"The output:"),(0,o.kt)(i.Z,{path:n(7840).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,o.kt)("h3",{id:"stopping-coroutines"},"Stopping Coroutines"),(0,o.kt)("p",null,"You can stop any coroutines by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"StopCoroutine")," method, with the name of the ",(0,o.kt)("inlineCode",{parentName:"p"},"IEnumerator")," as string:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'StopCoroutine("Rescue");\nStopCoroutine("Fade");\n')),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"A coroutine will also ",(0,o.kt)("span",{className:"orange-bold"},"automatically")," stop if the object that it\u2019s attached to is disabled by SetActive(false) or by destroying the object with Destroy().")),(0,o.kt)("p",null,"If you would like to ",(0,o.kt)("span",{className:"orange-bold"},"stop all Coroutines in the Behavior")," (Coroutines on the script), then you can use the method ",(0,o.kt)("inlineCode",{parentName:"p"},"StopAllCoroutines()"),". Note that this will only stop coroutines that are in the same script so other scripts won't be effected."),(0,o.kt)("h2",{id:"async-methods"},"C#: Async Methods and Multithreading With Task"),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"It is highly unlikely that you will need to implement async methods with extra threads in your game, but this section is added here to highlight ",(0,o.kt)("em",{parentName:"p"},"differences")," between async methods and coroutines."),(0,o.kt)("p",{parentName:"admonition"},"Unity's coroutines and C#'s async methods are ",(0,o.kt)("span",{className:"orange-bold"},"separate")," mechanisms for handling asynchronous operations. Unity's coroutines are specific to the Unity game engine and provide a way to perform tasks over time or in the background without blocking the main thread. C#'s async/await feature, on the other hand, is a ",(0,o.kt)("strong",{parentName:"p"},"general-purpose")," mechanism for handling asynchronous operations in C#.")),(0,o.kt)("p",null,"Async methods running on a separate threads are useful ",(0,o.kt)("strong",{parentName:"p"},"if")," you need to perform ",(0,o.kt)("span",{className:"orange-bold"},"very extensive computation")," that requires millions of CPU cycles while keeping your game responsive. In other words, we want to utilise the CPU ",(0,o.kt)("em",{parentName:"p"},"only after it's done")," computing whatever it needs for each frame."),(0,o.kt)("p",null,"Consider the following script. Here we test ",(0,o.kt)("strong",{parentName:"p"},"three")," different approach to perform an expensive ",(0,o.kt)("inlineCode",{parentName:"p"},"PerlinNoise")," computation: the vanilla way (just sequential), using a coroutine, and using another thread (",(0,o.kt)("inlineCode",{parentName:"p"},"Task"),") asynchronously. When key ",(0,o.kt)("inlineCode",{parentName:"p"},"c")," is pressed, this heavy computation will begin."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="HeavyComputation.cs"',title:'"HeavyComputation.cs"'},'using System.Collections;\nusing UnityEngine;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic enum method\n{\n    useVanilla = 0,\n    useCoroutine = 1,\n    useAsync = 2\n}\n\npublic class AsyncAwaitTest : MonoBehaviour\n{\n    public method method;\n    public int size = 10000;\n    private bool calculationState = false;\n\n\n    void Update()\n    {\n        if (Input.GetKeyDown("c"))\n        {\n            Debug.Log("Key c is pressed");\n            if (!calculationState)\n            {\n                switch (method)\n                {\n                    case (method.useVanilla):\n                        PerformCalculationsVanilla();\n                        break;\n                    case (method.useCoroutine):\n                        StartCoroutine(PerformCalculationsCoroutine());\n                        break;\n                    case (method.useAsync):\n                        PerformCalculationsAsync();\n                        break;\n                    default:\n                        break;\n                }\n                Debug.Log("Perform calculations dispatch done");\n            }\n        }\n\n        if (Input.GetKeyDown("q"))\n        {\n            Destroy(this.gameObject);\n        }\n    }\n\n    void PerformCalculationsVanilla()\n    {\n        System.Diagnostics.Stopwatch stopwatch = new System.Diagnostics.Stopwatch();\n        stopwatch.Start();\n        calculationState = true;\n        float[,] mapValues = new float[size, size];\n        for (int x = 0; x < size; x++)\n        {\n            for (int y = 0; y < size; y++)\n            {\n                mapValues[x, y] = Mathf.PerlinNoise(x * 0.01f, y * 0.01f);\n            }\n        }\n        calculationState = false;\n        stopwatch.Stop();\n        UnityEngine.Debug.Log("Real time elapsed using vanilla method: " + (stopwatch.Elapsed));\n        stopwatch.Reset();\n    }\n\n\n    IEnumerator PerformCalculationsCoroutine()\n    {\n        System.Diagnostics.Stopwatch stopwatch = new System.Diagnostics.Stopwatch();\n        stopwatch.Start();\n\n        calculationState = true;\n        float[,] mapValues = new float[size, size];\n        for (int x = 0; x < size; x++)\n        {\n            for (int y = 0; y < size; y++)\n            {\n                mapValues[x, y] = Mathf.PerlinNoise(x * 0.01f, y * 0.01f);\n            }\n            yield return null; // takes super long, only called at 60 times a second\n        }\n        calculationState = false;\n        stopwatch.Stop();\n        UnityEngine.Debug.Log("Real time elapsed Coroutine: " + (stopwatch.Elapsed));\n        stopwatch.Reset();\n        yield return null;\n    }\n\n    async void PerformCalculationsAsync()\n    {\n        System.Diagnostics.Stopwatch stopwatch = new System.Diagnostics.Stopwatch();\n        stopwatch.Start();\n        var result = await Task.Run(() =>\n        {\n            calculationState = true;\n            float[,] mapValues = new float[size, size];\n            for (int x = 0; x < size; x++)\n            {\n                for (int y = 0; y < size; y++)\n                {\n                    mapValues[x, y] = Mathf.PerlinNoise(x * 0.01f, y * 0.01f);\n                }\n            }\n            return mapValues;\n        });\n\n        calculationState = false;\n        stopwatch.Stop();\n        UnityEngine.Debug.Log("Real time elapsed using Async & Await: " + (stopwatch.Elapsed));\n        stopwatch.Reset();\n\n    }\n}\n\n')),(0,o.kt)("p",null,"In this video below, we bind the mouse right button click and movement with camera rotation to demonstrate how each method differs."),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-4/async-vs-coroutine.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("h4",{id:"vanilla-method"},"Vanilla Method"),(0,o.kt)("p",null,"The vanilla method causes the game to be ",(0,o.kt)("span",{className:"orange-bold"},"unresponsive")," for about 2 seconds."),(0,o.kt)("h4",{id:"coroutine"},"Coroutine"),(0,o.kt)("p",null,"When the method is changed into using a Coroutine, the time taken to complete the computation becomes close to 17 seconds instead (too long!). This is because of the ",(0,o.kt)("inlineCode",{parentName:"p"},"yield")," statement at each outer loop (means the next loop is only resumed at the next frame). When ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," is set to 1000 and the game is run at 60fps, it takes ",(0,o.kt)("span",{parentName:"p",className:"math math-inline"},(0,o.kt)("span",{parentName:"span",className:"katex"},(0,o.kt)("span",{parentName:"span",className:"katex-mathml"},(0,o.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,o.kt)("semantics",{parentName:"math"},(0,o.kt)("mrow",{parentName:"semantics"},(0,o.kt)("mfrac",{parentName:"mrow"},(0,o.kt)("mn",{parentName:"mfrac"},"1000"),(0,o.kt)("mn",{parentName:"mfrac"},"60")),(0,o.kt)("mo",{parentName:"mrow"},"="),(0,o.kt)("mn",{parentName:"mrow"},"16.67")),(0,o.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\frac{1000}{60} = 16.67")))),(0,o.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"1.1901em",verticalAlign:"-0.345em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},(0,o.kt)("span",{parentName:"span",className:"mopen nulldelimiter"}),(0,o.kt)("span",{parentName:"span",className:"mfrac"},(0,o.kt)("span",{parentName:"span",className:"vlist-t vlist-t2"},(0,o.kt)("span",{parentName:"span",className:"vlist-r"},(0,o.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.8451em"}},(0,o.kt)("span",{parentName:"span",style:{top:"-2.655em"}},(0,o.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,o.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},"60")))),(0,o.kt)("span",{parentName:"span",style:{top:"-3.23em"}},(0,o.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,o.kt)("span",{parentName:"span",className:"frac-line",style:{borderBottomWidth:"0.04em"}})),(0,o.kt)("span",{parentName:"span",style:{top:"-3.394em"}},(0,o.kt)("span",{parentName:"span",className:"pstrut",style:{height:"3em"}}),(0,o.kt)("span",{parentName:"span",className:"sizing reset-size6 size3 mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},(0,o.kt)("span",{parentName:"span",className:"mord mtight"},"1000"))))),(0,o.kt)("span",{parentName:"span",className:"vlist-s"},"\u200b")),(0,o.kt)("span",{parentName:"span",className:"vlist-r"},(0,o.kt)("span",{parentName:"span",className:"vlist",style:{height:"0.345em"}},(0,o.kt)("span",{parentName:"span"}))))),(0,o.kt)("span",{parentName:"span",className:"mclose nulldelimiter"})),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,o.kt)("span",{parentName:"span",className:"mrel"},"="),(0,o.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,o.kt)("span",{parentName:"span",className:"base"},(0,o.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,o.kt)("span",{parentName:"span",className:"mord"},"16.67")))))," seconds to complete just this computation. This is way too long of a wait even though the system stays responsive in the meantime."),(0,o.kt)("h4",{id:"async--await-with-task"},"Async & Await with Task"),(0,o.kt)("p",null,"What we wanted is to ",(0,o.kt)("strong",{parentName:"p"},"utilise")," our CPU as much as possible ",(0,o.kt)("em",{parentName:"p"},"while staying responsive"),". To do so, we can run ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function and await for Task completion. Remember that ",(0,o.kt)("inlineCode",{parentName:"p"},"Update")," is only called 60 times a second (where we check for inputs, execute basic game logic, etc), so there\u2019s plenty of leftover time that we can use to complete this calculation function. It still takes slightly more than 2 seconds to complete the computation. This shows that using ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function does not (necessarily) make any computation time faster than the vanilla method, but in the meantime, the system is still ",(0,o.kt)("strong",{parentName:"p"},"responsive"),"."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"Calling an ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function without any ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," in its body results in synchronous execution. We need to ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," some ",(0,o.kt)("inlineCode",{parentName:"p"},"Task")," as shown in the example above, e.g: ",(0,o.kt)("inlineCode",{parentName:"p"},"var result = await Task.Run(()"),".")),(0,o.kt)("h2",{id:"comparison-with-coroutine"},"Comparison With Coroutine"),(0,o.kt)("p",null,"This section briefly covers the comparison between the two. There\u2019s no better or worse solution, and you can simply choose the solution that suits your project best. The content for this section is distilled from ",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=7eKi6NKri6I"},"this")," video."),(0,o.kt)("h3",{id:"async-functions-always-complete"},"Async Functions Always Complete"),(0,o.kt)("p",null,"Async functions ",(0,o.kt)("span",{className:"orange-bold"},"always")," runs into completion because they continue to run even after the MonoBehavior is destroyed, while Coroutines are run ",(0,o.kt)("span",{className:"orange-bold"},"on")," the GameObject. Therefore, disabling the gameobject will cause any coroutine running on it to stop but ",(0,o.kt)("span",{className:"orange-bold"},"doesn\u2019t exit")," naturally."),(0,o.kt)("p",null,"Consider the following script:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="TestDestroy.cs showLineNumbers"',title:'"TestDestroy.cs','showLineNumbers"':!0},'using System.Collections;\nusing UnityEngine;\nusing System.Threading.Tasks;\npublic class TestDestroy : MonoBehaviour\n{\n    async void Start()\n    {\n        StartCoroutine(Sampletask());\n        SampleTaskAsync();\n        await Task.Delay(1000);\n        Destroy(gameObject);\n    }\n\n    async void SampleTaskAsync()\n    {\n        // This task will finish, even though it\'s object is destroyed\n        Debug.Log($"Async Task Started for object {this.gameObject.name}");\n        await Task.Delay(5000);\n        Debug.Log($"Async Task Ended for object {this.gameObject.name}");\n    }\n\n    IEnumerator Sampletask()\n    {\n        // This task won\'t finish, it will be stopped as soon as the object is destroyed\n        Debug.Log($"Coroutine Started for object {this.gameObject.name}");\n        yield return new WaitForSeconds(5);\n        Debug.Log($"Coroutine Ended for object {this.gameObject.name}");\n    }\n}\n')),(0,o.kt)("p",null,"Attaching the above script and running it will result in the output:"),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-4/test-destroy-async.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("p",null,"Notice how the message ",(0,o.kt)("inlineCode",{parentName:"p"},"Coroutine Ended...")," never gets printed out, but instruction at line 19 causes an error because we tried to access the already destroyed GameObject's name (since ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," function always completes). Therefore you have to be careful when accessing the instance's member in async functions."),(0,o.kt)("h4",{id:"memory-leak-with-coroutine"},"Memory Leak With Coroutine"),(0,o.kt)("p",null,"On the other hand, Coroutines might result in ",(0,o.kt)("span",{className:"orange-bold"},"memory leak")," if not used properly since it does not exit if the gameObject has been destroyed. Assets in Unity (textures, materials, etc) are ",(0,o.kt)("span",{className:"orange-bold"},"not")," garbage collected as readily as other types. Unity will clean up unused assets on scene loads, but to keep them from piling up it's our responsibility to manage the assets we're creating, and ",(0,o.kt)("inlineCode",{parentName:"p"},"Destroy()")," them when we're finished."),(0,o.kt)("p",null,"In the following example, the ",(0,o.kt)("inlineCode",{parentName:"p"},"finally")," block never gets executed and thus results in memory leak."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"    IEnumerator RenderEffect(UnityEngine.UI.RawImage r)\n    {\n        var texture = new RenderTexture(1024, 1024, 0);\n        try\n        {\n            for (int i = 0; i < 1000; i++)\n            {\n                // do something with r and texture\n                // then give control back to Unity after one interation\n                yield return null;\n            }\n        }\n        finally\n        {\n            texture.Release();\n        }\n    }\n")),(0,o.kt)("h3",{id:"stopping-async-functions"},"Stopping Async Functions"),(0,o.kt)("p",null,"To be sure that Coroutines always exit especially on destroyed GameObjects, we need to be mindful to ",(0,o.kt)("inlineCode",{parentName:"p"},"StopCoroutine(...)")," during ",(0,o.kt)("inlineCode",{parentName:"p"},"onDisable")," of the GameObject. Likewise, we can also cancel the running of async functions using cancellation ",(0,o.kt)("strong",{parentName:"p"},"tokens"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},'    // declare and initialise at Start()\n    CancellationTokenSource token;\n\n    void Start(){\n        token = new CancellationTokenSource();\n    }\n\n\n    async void PerformCalculation(){\n\n        // passed the token when defining Task\n        var result = await Task.Run(() =>\n        {\n            calculationState = true;\n            float[,] mapValues = new float[size, size];\n            // ... implementation\n            for (.....){\n                // ... implementation\n                // periodically check for cancellation token request\n                if (token.IsCancellationRequested)\n                {\n                    Debug.Log("Task Stop Requested");\n                    return mapValues;\n                    }\n            }\n            return result;\n        }, token.Token); // token passed as second argument of Task.Run()\n    }\n\n    // set the token to Cancel the function on object disable\n    void OnDisable()\n    {\n        Debug.Log("itemDisabled");\n        token.Cancel();\n    }\n\n')),(0,o.kt)("h3",{id:"return-values"},"Return Values"),(0,o.kt)("p",null,"We cannot return anything in a Coroutine, but async functions can the following return types (thats why we can ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," its results!):"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task?view=net-7.0"},"Task"),", for an async method that performs an operation but returns no value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1?view=net-7.0"},"Task<TResult",">"),", for an async method that returns a value."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"void"),", for an event handler.")),(0,o.kt)("p",null,"For example, the following async function returns a ",(0,o.kt)("inlineCode",{parentName:"p"},"Sprite")," placed at a ",(0,o.kt)("inlineCode",{parentName:"p"},"path"),"."),(0,o.kt)("admonition",{title:"Resource Path",type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"Resources.Load")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"Resources.LoadAsync"),", you can load an asset of the requested ",(0,o.kt)("inlineCode",{parentName:"p"},"type")," stored at a ",(0,o.kt)("inlineCode",{parentName:"p"},"path")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"Resources")," folder. You must first create the ",(0,o.kt)("inlineCode",{parentName:"p"},"Assets/Resources")," folder for this to work. Note that the ",(0,o.kt)("inlineCode",{parentName:"p"},"path")," is case insensitive and must ",(0,o.kt)("span",{className:"orange-bold"},"not")," contain a file extension. ",(0,o.kt)("a",{parentName:"p",href:"https://docs.unity3d.com/ScriptReference/Resources.Load.html"},"Read the full documentation here"),".")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"    async Task<Sprite> LoadAsSprite_Task(string path)\n    {\n        // getting sprite inside Assets/Resources/ folder\n        var resource = await Resources.LoadAsync<Sprite>(path);\n        return (resource as Sprite);\n    }\n")),(0,o.kt)("p",null,"We can call them as such in ",(0,o.kt)("inlineCode",{parentName:"p"},"Start()")," (notice how the Start method has to be ",(0,o.kt)("inlineCode",{parentName:"p"},"async")," now to ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," this ",(0,o.kt)("inlineCode",{parentName:"p"},"Task"),"), and print some quick test in ",(0,o.kt)("inlineCode",{parentName:"p"},"Update()")," to confirm if ",(0,o.kt)("inlineCode",{parentName:"p"},"Update()")," is run at least for ",(0,o.kt)("strong",{parentName:"p"},"one")," frame before ",(0,o.kt)("inlineCode",{parentName:"p"},"Start()")," is continued, and we can obtain some information about the return value of ",(0,o.kt)("inlineCode",{parentName:"p"},"LoadAsSprite_Task")," async function. Here's an example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cs",metastring:'title="AsyncReturnValue.cs"',title:'"AsyncReturnValue.cs"'},'\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class AsyncReturnValue : MonoBehaviour\n{\n    // Start is called before the first frame update\n    private bool testTask = false;\n    private int frame = 0;\n    async void Start()\n    {\n        Debug.Log("Start method begins...");\n        Sprite s = await LoadAsSprite_Task("Sprites/play-button"); // the actual file is at Assets/Resources/play-button.png\n        testTask = true;\n        Debug.Log("The sprite: " + s.name + " has been loaded.");\n        Debug.Log("Start method completes in frame: " + frame.ToString());\n    }\n    void Update()\n    {\n        frame++;\n        if (!testTask)\n            Debug.Log("Update called at frame: " + frame);\n    }\n\n    async Task<Sprite> LoadAsSprite_Task(string path)\n    {\n        // getting sprite inside Assets/Resources/ folder\n        ResourceRequest request = Resources.LoadAsync<Sprite>(path);\n        // While the request is not done, yield to Unity\'s coroutine system.\n        while (!request.isDone)\n        {\n            await Task.Yield();\n        }\n\n        return (Sprite)request.asset;\n    }\n\n}\n\n')),(0,o.kt)("p",null,"Here's the console output:"),(0,o.kt)(i.Z,{path:n(5054).Z,widthPercentage:"100%",mdxType:"ImageCard"}),(0,o.kt)("p",null,"It shows that ",(0,o.kt)("inlineCode",{parentName:"p"},"Start")," is called first as usual, but ",(0,o.kt)("strong",{parentName:"p"},"asynchronously"),", allowing ",(0,o.kt)("inlineCode",{parentName:"p"},"Update")," to advance and increase the frame value. When the sprite has been loaded, the Start method resumes and print the ",(0,o.kt)("inlineCode",{parentName:"p"},"Start method completes")," message."),(0,o.kt)("admonition",{type:"warning"},(0,o.kt)("p",{parentName:"admonition"},"We can't ",(0,o.kt)("inlineCode",{parentName:"p"},"await")," a Coroutine, it does not make sense because Unity's coroutines are not Task-based and don't return a Task object that you can ",(0,o.kt)("inlineCode",{parentName:"p"},"await"),". However you can achieve similar result such as using a flag that will be set to ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," once a Coroutine completes.")),(0,o.kt)("h2",{id:"summary"},"Summary"),(0,o.kt)("p",null,"Choosing between coroutines and async/await Task isn't always straightforward due to their differing functionalities."),(0,o.kt)("p",null,"It's essential to understand that asynchronous code ",(0,o.kt)("span",{className:"orange-bold"},"doesn't always imply multithreading"),", and the behavior can vary depending on the specific APIs and libraries you're working with."),(0,o.kt)("p",null,"Coroutines are best for ",(0,o.kt)("em",{parentName:"p"},"fire-and-forget")," tasks like fading the screen, replenishing health bar, triggering explosion on crates two seconds after it collides with the player and similar tasks, while async is essential for processing intensive tasks in the background ",(0,o.kt)("em",{parentName:"p"},"without")," causing game stalls. Coroutines can be ",(0,o.kt)("strong",{parentName:"p"},"tricky"),", but async functions can get ",(0,o.kt)("strong",{parentName:"p"},"complex")," when handling task cancellation. In practice, using both methods in your project is common. As a broadly general rule, it may be simpler to employ coroutines for object-related game logic and reserve async for situations like executing lengthy background tasks."),(0,o.kt)("h2",{id:"powerup-bug"},"Fix The Powerup Bug"),(0,o.kt)("p",null,"If you follow the tutorial exactly, you will have a particular powerup bug. While our powerup works at first glance, having the collider placed above the box will cause problems if Mario approached it from above as follows:"),(0,o.kt)(s.Z,{path:"https://50033.s3.ap-southeast-1.amazonaws.com/week-4/bug-powerup.mp4",widthPercentage:"100%",mdxType:"VideoItem"}),(0,o.kt)("p",null,"The Starman powerup looks alright if we only collide with it from below, however it mistakenly collided with Mario even before spawned. On the other hand, the Magic Mushroom powerup didn't have that."),(0,o.kt)("p",null,"You need to disable the collider and set its ",(0,o.kt)("inlineCode",{parentName:"p"},"RigidBody2D.type")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"static")," at first, and then enable the collider and set the ",(0,o.kt)("inlineCode",{parentName:"p"},"RigidBody2D.type")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"dynamic")," upon ",(0,o.kt)("inlineCode",{parentName:"p"},"SpawnPowerup()"),". However, you can't do it all in the same function because adding Impulse Force to a currently static body type will ",(0,o.kt)("span",{className:"orange-bold"},"not work"),". Even though you have changed its type to ",(0,o.kt)("inlineCode",{parentName:"p"},"dynamic")," in this frame, the Engine does not know yet and so you technically need to wait until the ",(0,o.kt)("strong",{parentName:"p"},"next frame")," to add the Impulse force to move the powerup once spawned. You can utilise Coroutine or utilise ",(0,o.kt)("inlineCode",{parentName:"p"},"await Task.Delay()")," for this."))}h.isMDXComponent=!0},5054:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-09-15-17-59-59-21283c50f10d6340181c8c8f33786474.png"},7840:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/2023-09-15-11-49-56-46a9b4c24e7164bb369cf0a28d5af5be.png"}}]);