"use strict";(self.webpackChunksite_docusaurus_template=self.webpackChunksite_docusaurus_template||[]).push([[9762],{60283:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"general/cheats","title":"God Mode for Development","description":"When you\u2019re making fun or experimental projects, you often hit the same playtesting pain points like dying constantly during testing, running out of resources, want to skip level geometry, and want consistency across sessions.","source":"@site/resources/general/cheats.md","sourceDirName":"general","slug":"/general/cheats","permalink":"/50033/resources/general/cheats","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"Asset Library","permalink":"/50033/resources/general/assets-db"}}');var a=i(74848),s=i(28453);i(53398),i(19894),i(88761),i(89166);const o={sidebar_position:5},l="God Mode for Development",r={},d=[{value:"Example Approach: Static Class",id:"example-approach-static-class",level:2},{value:"Explanation",id:"explanation",level:2},{value:"Public API",id:"public-api",level:3},{value:"Change notifications",id:"change-notifications",level:3},{value:"Internal Cheat Registry",id:"internal-cheat-registry",level:3},{value:"Extension Hook and Adding Cheat (private)",id:"extension-hook-and-adding-cheat-private",level:3},{value:"Bootstrap",id:"bootstrap",level:3},{value:"Overlay",id:"overlay",level:3},{value:"<code>Debug.isDebugBuild</code>",id:"debugisdebugbuild",level:3},{value:"Usage with Polling",id:"usage-with-polling",level:2},{value:"Usage with Event",id:"usage-with-event",level:2},{value:"Extending Cheats",id:"extending-cheats",level:2},{value:"Usage with New API (Extended Cheats)",id:"usage-with-new-api-extended-cheats",level:2},{value:"Testing",id:"testing",level:2}];function c(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"god-mode-for-development",children:"God Mode for Development"})}),"\n",(0,a.jsxs)(n.p,{children:["When you\u2019re making fun or experimental projects, you often hit the same playtesting ",(0,a.jsx)(n.strong,{children:"pain points"})," like dying constantly during testing, running out of resources, want to skip level geometry, and want consistency across sessions."]}),"\n",(0,a.jsxs)(n.p,{children:["Most games should have some kind of God Mode enabled (infinite resource, skip levels, teleport anywhere, etc). There are ",(0,a.jsx)(n.strong,{children:"many"})," ways to implement this but what you want is something so simple and portable that you can use across projects and easy to extend and modify should you need more God Features, has a clear ",(0,a.jsx)(n.strong,{children:"UI"})," to know which cheat is enabled while being ",(0,a.jsx)(n.em,{children:"backward compatible"}),"."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsx)(n.p,{children:"Any design that requires zero setup and maintenance is a good design."})}),"\n",(0,a.jsx)(n.h2,{id:"example-approach-static-class",children:"Example Approach: Static Class"}),"\n",(0,a.jsx)(n.p,{children:"You can create a static class that contains flags on whether God Mode is enabled in your game. You will then access them from other scripts to determine the logic:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'// GodModeManager.cs \u2014 drop anywhere in Assets/\n// Two usage methods in gameplay code:\n// [POLLING] if (GodModeManager.God) { /* ignore damage */ }\n// [EVENT-BASED] GodModeManager.OnAnyChange += HandleCheatChange;  // react when toggled\n\nusing System;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic static partial class GodModeManager\n{\n    // sample public flags (stable API)\n    public static bool God { get; private set; } // invulnerable\n    public static bool Infinite { get; private set; } // infinite resources\n    public static bool Noclip { get; private set; } // ignore collisions\n\n\n    // subscribe to this to react once whenever ANY cheat flips\n    public static event Action OnAnyChange;\n\n    // internal registry for scalable toggles/hotkeys/persistence\n    private struct CheatDef\n    {\n        public string Name;\n        public string PrefKey;\n        public Func<bool> Getter;\n        public Action<bool> Setter;   // MUST invoke OnAnyChange\n        public KeyCode? Hotkey;\n    }\n\n    private static readonly List<CheatDef> _defs = new();\n    private static bool _bootstrapped;\n\n\n\n    // extension hook: compile-time only (implemented in your own partial file)\n    static partial void RegisterExtraCheats();\n    private static void AddCheat(\n        string name,\n        string playerPrefsKey,\n        Func<bool> getter,\n        Action<bool> assignCoreField,\n        KeyCode? hotkey = null)\n    {\n        // load saved value for dev builds; default false otherwise\n        bool saved = Debug.isDebugBuild && PlayerPrefs.GetInt(playerPrefsKey, 0) == 1;\n\n        // core setter: persist (dev only), assign field, and notify subscribers\n        void CoreSetter(bool v)\n        {\n            if (Debug.isDebugBuild)\n            {\n                PlayerPrefs.SetInt(playerPrefsKey, v ? 1 : 0);\n                PlayerPrefs.Save();\n            }\n            assignCoreField(v);       // update the backing field (e.g., God = v)\n            OnAnyChange?.Invoke();    // notify once per toggle\n        }\n\n        // initialize to saved value without double notify\n        assignCoreField(saved);\n\n        _defs.Add(new CheatDef\n        {\n            Name = name,\n            PrefKey = playerPrefsKey,\n            Getter = getter,\n            Setter = CoreSetter,\n            Hotkey = hotkey\n        });\n    }\n\n    // bootstrap: only active in Editor/Development builds\n    [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.AfterSceneLoad)]\n    private static void Bootstrap()\n    {\n        if (_bootstrapped) return;\n        _bootstrapped = true;\n        if (!Debug.isDebugBuild) return;\n\n        // register legacy cheats (preserves existing API and PlayerPrefs keys)\n        AddCheat("God", "GodModeManager.God", () => God, v => God = v, KeyCode.F1);\n        AddCheat("Infinite", "GodModeManager.Infinite", () => Infinite, v => Infinite = v, KeyCode.F2);\n        AddCheat("Noclip", "GodModeManager.Noclip", () => Noclip, v => Noclip = v, KeyCode.F3);\n        // call your compile-time extensions (if any)\n        RegisterExtraCheats();\n        // spawn overlay holder\n        var go = new GameObject("GodModeManagerOverlay");\n        go.hideFlags = HideFlags.DontSave;\n        UnityEngine.Object.DontDestroyOnLoad(go);\n        go.AddComponent<GodModeOverlay>();\n    }\n\n    // tiny overlay + hotkeys (auto-built from registry)\n    private class GodModeOverlay : MonoBehaviour\n    {\n        bool show = true;\n        Rect area = new Rect(10, 10, 240, 140);\n\n        void Update()\n        {\n            if (Input.GetKeyDown(KeyCode.BackQuote)) show = !show;\n\n            foreach (var d in _defs)\n            {\n                if (d.Hotkey.HasValue && Input.GetKeyDown(d.Hotkey.Value))\n                {\n                    // toggle via registered setter (fires OnAnyChange once)\n                    d.Setter(!d.Getter());\n                }\n            }\n        }\n\n        void OnGUI()\n        {\n            if (!show) return;\n\n            area.height = 20 + 26 * (_defs.Count + 2);\n\n            GUILayout.BeginArea(area, GUI.skin.box);\n            GUILayout.Label("<b>God Mode Manager</b>", new GUIStyle(GUI.skin.label) { richText = true });\n\n            foreach (var d in _defs)\n            {\n                bool v = d.Getter();\n                bool nv = GUILayout.Toggle(v, $" {d.Name}" + (d.Hotkey.HasValue ? $"  ({d.Hotkey.Value})" : ""));\n                if (nv != v)\n                {\n                    d.Setter(nv);                    // notifies once\n                }\n            }\n\n            GUILayout.Space(4);\n            GUILayout.Label("` show/hide");\n            GUILayout.EndArea();\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"explanation",children:"Explanation"}),"\n",(0,a.jsx)(n.p,{children:"This section explains the purpose of each part of the code above."}),"\n",(0,a.jsx)(n.h3,{id:"public-api",children:"Public API"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:'public static bool God      { get; private set; }\npublic static bool Infinite { get; private set; }\npublic static bool Noclip   { get; private set; }\n\npublic static void SetGod(bool v)      => SetFlag("God", v);\npublic static void SetInfinite(bool v) => SetFlag("Infinite", v);\npublic static void SetNoclip(bool v)   => SetFlag("Noclip", v);\n\n'})}),"\n",(0,a.jsx)(n.p,{children:"These are the flags you use in gameplay code if you choose to poll and check. For instance,"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"if (GodModeManager.God) { /* ignore damage */ }\n"})}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"SetX()"})," wrappers call into the internal system (",(0,a.jsx)(n.code,{children:"SetFlag"}),") so that ",(0,a.jsx)(n.strong,{children:"toggling"})," a cheat updates persistence, events, and UI consistently."]}),"\n",(0,a.jsx)(n.h3,{id:"change-notifications",children:"Change notifications"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public static event Action OnAnyChange;\n"})}),"\n",(0,a.jsxs)(n.p,{children:["This lets other systems subscribe and react ",(0,a.jsx)(n.strong,{children:"immediately"})," when any cheat flips and avoid per-frame polling. See ",(0,a.jsx)(n.a,{href:"#usage-with-event",children:"this"})," section for usage."]}),"\n",(0,a.jsx)(n.h3,{id:"internal-cheat-registry",children:"Internal Cheat Registry"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"private struct CheatDef\n{\n    public string Name;\n    public string PrefKey;\n    public Func<bool> Getter;\n    public Action<bool> Setter;\n    public KeyCode? Hotkey;\n}\n\nprivate static readonly List<CheatDef> _defs = new();\n\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Each cheat is represented by a ",(0,a.jsx)(n.code,{children:"CheatDef"}),". It holds everything the manager needs to display it in the cheat overlay. ",(0,a.jsx)(n.code,{children:"_defs"})," is the ",(0,a.jsx)(n.strong,{children:"master"})," list that holds all registered cheats, along with how to get/set their values and which hotkeys toggle them. The overlay simply loops through this list to build the UI."]}),"\n",(0,a.jsx)(n.h3,{id:"extension-hook-and-adding-cheat-private",children:"Extension Hook and Adding Cheat (private)"}),"\n",(0,a.jsxs)(n.p,{children:["The extension hook ",(0,a.jsx)(n.code,{children:"RegisterExtraCheats"})," is an empty partial method in the core file, and we can add extra cheats by writing a second file, see this ",(0,a.jsx)(n.a,{href:"#extending-cheats",children:"section"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["The method ",(0,a.jsx)(n.code,{children:"AddCheat"})," is only called during bootstrap or by extension partial classes. It register new cheats in ",(0,a.jsx)(n.code,{children:"_defs"}),", loads previous saved value (if dev build) and sets the backing field. Setter automatically updates persistence + field + fires ",(0,a.jsx)(n.code,{children:"OnAnyChange"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"bootstrap",children:"Bootstrap"}),"\n",(0,a.jsxs)(n.p,{children:["Runs automatically after the first scene loads (thanks to ",(0,a.jsx)(n.code,{children:"RuntimeInitializeOnLoadMethod"}),"). It guards ",(0,a.jsx)(n.code,{children:"_bootstrapped"})," (run only once) and ",(0,a.jsx)(n.code,{children:"Debug.isDebugBuild"})," (only runs in Editor or Dev builds, skips in Release)."]}),"\n",(0,a.jsx)(n.p,{children:"Then it does:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Registers the built-in cheats (God, Infinite, Noclip)"}),"\n",(0,a.jsxs)(n.li,{children:["Calls ",(0,a.jsx)(n.code,{children:"RegisterExtraCheats"})," (so our partial extensions can add theirs)"]}),"\n",(0,a.jsx)(n.li,{children:"Creates a persistent hidden GameObject with the overlay UI so we know what cheats are ON"}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"overlay",children:"Overlay"}),"\n",(0,a.jsxs)(n.p,{children:["This class provides a simple IMGUI panel with toggles for each cheat. It toggles with backtick (`) to show/hide. Hotkeys (F1, F2, F3, \u2026) flip cheats instantly. Because it reads ",(0,a.jsx)(n.code,{children:"_defs"})," every frame, all cheats (core + extensions) appear automatically."]}),"\n",(0,a.jsx)("img",{src:"{{ site.baseurl }}//resources/images/cheats/2025-09-25-10-48-50.png",class:"center_seventy"}),"\n",(0,a.jsx)(n.h3,{id:"debugisdebugbuild",children:(0,a.jsx)(n.code,{children:"Debug.isDebugBuild"})}),"\n",(0,a.jsx)(n.p,{children:"This is a property Unity fills in for us at runtime."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"In the Editor Play mode: always true."}),"\n",(0,a.jsx)(n.li,{children:"In a Development Build: true."}),"\n",(0,a.jsx)(n.li,{children:"In a Release/normal Build: false."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"You can set in Build Settings whether you want your game to be made as Development Build (tick the box)."}),"\n",(0,a.jsx)("img",{src:"{{ site.baseurl }}//resources/images/cheats/2025-09-25-10-37-37.png",class:"center_seventy"}),"\n",(0,a.jsx)(n.h2,{id:"usage-with-polling",children:"Usage with Polling"}),"\n",(0,a.jsx)(n.p,{children:"Use the flags right away where they matter"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",children:"public void ApplyDamage(int dmg)\n{\n    if (GodModeManager.God) return; // invulnerable\n    hp = Mathf.Max(0, hp - dmg);\n}\n\nvoid ConsumeAmmo(int amount)\n{\n    if (GodModeManager.Infinite) return; // never decrease\n    ammo = Mathf.Max(0, ammo - amount);\n}\n\nvoid Update()\n{\n    if (GodModeManager.Noclip)\n    {\n        controller.detectCollisions = false;\n        FreeFly();\n    }\n    else\n    {\n        controller.detectCollisions = true;\n        NormalMove();\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"usage-with-event",children:"Usage with Event"}),"\n",(0,a.jsx)(n.p,{children:"Subscribe to OnAnyChange to flip systems on/off only when a cheat changes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="NoclipBinder.cs"',children:"public class NoclipBinder : MonoBehaviour\n{\n    void OnEnable()  => GodModeManager.OnAnyChange += Apply;\n    void OnDisable() => GodModeManager.OnAnyChange -= Apply;\n\n    void Start() => Apply(); // apply current state immediately\n\n    void Apply()\n    {\n        if (GodModeManager.Noclip) EnableNoclip();\n        else                       DisableNoclip();\n    }\n\n    void EnableNoclip()\n    {\n        foreach (var c in GetComponentsInChildren<Collider>()) c.enabled = false;\n        var rb = GetComponent<Rigidbody>(); if (rb) rb.isKinematic = true;\n    }\n\n   void DisableNoclip()\n    {\n        foreach (var c in GetComponentsInChildren<Collider>()) c.enabled = true;\n        var rb = GetComponent<Rigidbody>(); if (rb) rb.isKinematic = false;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"extending-cheats",children:"Extending Cheats"}),"\n",(0,a.jsxs)(n.p,{children:["This only works at compile time. It is not a good idea to extend cheats during runtime.\nSimply create a new file in ",(0,a.jsx)(n.code,{children:"Assets/Scripts"})," (say ",(0,a.jsx)(n.code,{children:"GodModeManager.OneHitKill.cs"}),"), that extend the partial class ",(0,a.jsx)(n.code,{children:"GodModeManager"})," and implement 2 things:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["The public flag of the cheat that can be read in gameplay code (",(0,a.jsx)(n.code,{children:"publid static bool XX"}),")"]}),"\n",(0,a.jsx)(n.li,{children:"Register the extra cheat"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="GodModeManager.OneHitKill.cs"',children:'// adds "OneHitKill" at compile time (no runtime registration allowed).\n\nusing UnityEngine;\n\npublic static partial class GodModeManager\n{\n    // 1. public flag you can read in gameplay code\n    public static bool OneHitKill { get; private set; }\n\n    // 2. register this cheat during bootstrap\n    static partial void RegisterExtraCheats()\n    {\n        AddCheat(\n            "OneHitKill",                     // name shown in overlay\n            "GodModeManager.OneHitKill",      // PlayerPrefs key\n            () => OneHitKill,                 // how to read the field\n            v => OneHitKill = v,              // how to write the field\n            KeyCode.F4                        // optional hotkey\n        );\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"usage-with-new-api-extended-cheats",children:"Usage with New API (Extended Cheats)"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="Player.cs"',children:"\n// damage handling\npublic void ApplyDamage(int dmg)\n{\n    if (GodModeManager.God) return;                // invulnerable\n    if (GodModeManager.OneHitKill) dmg = 999999;   // example usage of new API\n    hp = Mathf.Max(0, hp - dmg);\n}\n\n// react once when toggled\nvoid OnEnable()  => GodModeManager.OnAnyChange += ApplyCheats;\nvoid OnDisable() => GodModeManager.OnAnyChange -= ApplyCheats;\nvoid Start()     => ApplyCheats();\n\nvoid ApplyCheats()\n{\n    if (GodModeManager.Noclip) EnableNoclip(); else DisableNoclip();\n}\n\n// implement Enable/DisableNoClip methods afterwards\n"})}),"\n",(0,a.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,a.jsx)(n.p,{children:"Attach this script on any empty GameObject in your Scene to test whether the cheat system is working."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-cs",metastring:'title="GodModeTester.cs"',children:'using UnityEngine;\n\npublic class GodModeTester : MonoBehaviour\n{\n    void OnEnable()\n    {\n        // Event-based: subscribe once, react whenever ANY cheat changes\n        GodModeManager.OnAnyChange += PrintCheats;\n    }\n\n    void OnDisable()\n    {\n        GodModeManager.OnAnyChange -= PrintCheats;\n    }\n\n    void Update()\n    {\n        // Polling: check flags each frame\n        if (GodModeManager.God)\n            Debug.Log("[GODMODETESTER] Polling: God mode is ON (invulnerable)");\n        if (GodModeManager.Infinite)\n            Debug.Log("[GODMODETESTER]Polling: Infinite resources are ON");\n        if (GodModeManager.Noclip)\n            Debug.Log("[GODMODETESTER]Polling: Noclip is ON (collisions disabled)");\n        if (GodModeManager.OneHitKill)\n            Debug.Log("[GODMODETESTER]Polling: OneHitKill is ON (killing enabled)");\n\n    }\n\n    // Event-based: called automatically when any cheat flips\n    void PrintCheats()\n    {\n        Debug.Log($"[GODMODETESTER][OnAnyChange] Cheats now: " +\n                  $"God={GodModeManager.God}, " +\n                  $"Infinite={GodModeManager.Infinite}, " +\n                  $"Noclip={GodModeManager.Noclip} " +\n                  $"OneHitKill={GodModeManager.OneHitKill}");\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);